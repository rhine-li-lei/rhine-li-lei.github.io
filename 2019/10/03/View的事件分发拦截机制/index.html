<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    View 的事件分发拦截机制 |
    
    rhine(黎磊)</title>
  
    <link rel="shortcut icon" href="/images/ProfilePicture.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  

<article id="post-View的事件分发拦截机制" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      View 的事件分发拦截机制
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/10/03/View的事件分发拦截机制/" class="article-date">
  <time datetime="2019-10-03T09:02:01.000Z" itemprop="datePublished">2019-10-03</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android系列/">Android系列</a>
  </div>

      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>这一个知识点也是写烂了的，可是作为 Android 开发者又不得不学习这部分，学习了呢，总觉得要写点东西出来才觉得有感觉，得，就有这一篇文章了。</p>
<p><strong>API 27</strong></p>
<h2 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h2><p>在单点触摸中，我们对屏幕的点击，滑动，抬起等一系的动作都是由一个一个MotionEvent对象组成的触摸事件。MotionEvent 是对一个对一个事件的封装，里面包括动作、坐标等等信息，根据不同动作，主要有以下三种事件类型：</p>
<ol>
<li>ACTION_DOWN：手指刚接触屏幕，按下去的那一瞬间产生该事件</li>
<li>ACTION_MOVE：手指在屏幕上移动时候产生该事件</li>
<li>ACTION_UP：手指从屏幕上松开的瞬间产生该事件</li>
</ol>
<p>要要注意触摸事件不是独立的，而是成组的，每一组事件都是由按下事件开始的，由抬起事件或者取消事件结束。我们把<strong>由 ACTION_DOWN 开始（按下），ACTION_UP （抬起）或者 ACTION_CANCEL（取消） 结束</strong>的一组事件称为<strong>事件序列</strong>或者说<strong>事件流</strong>。取消事件是一种特殊的事件，它对应的是事件序列非人为的提前结束。</p>
<p>举个例子：<br>点击事件：ACTION_DOWN  -&gt; ACTION_UP<br>滑动事件：ACTION_DOWN  -&gt;  ACTION_MOVE -&gt; … -&gt; ACTION_MOVE -&gt; ACTION_UP </p>
<p>Android 每产生一个 TouchEvent 事件，他会先问最表面是否消费，如果不消费就交给他的ViewGroup，一层一层向上传递，最终被<strong>消费</strong>掉（消费就是以为着事件被处理了，代码体现为返回值，true为消费，false为不消费，<strong>消费后不再传递</strong>）。TouchEvent 不断产生，事件就会不断分发，处理，实现对事件对应的操作进行判断和反馈处理。</p>
<p>还是举个栗子：<br>一个button被点击一下，就会产生两个 TouchEvent 事件，当第一个 TouchEvent 产生，button 发现自己被按下，背景风格变成按下状态，如水波纹、颜色变深等。当第二个Up 的 TouchEvent 产生、分发的时候，button判别自己被点击，背景风格恢复默认状态，并且如果设置了<code>ClickListener</code>的话，调用 <code>OnClick</code> 方法。</p>
<p>那么如果你的ViewGroup里面不止一个View呢（不是废话吗），不止一个ViewGroup呢？那是不是我就要制定一个机制来决定谁来处理这个事件啊？安排</p>
<p>当事件刚触摸到屏幕的时候，即 ACTION_DOWN 这个 MotionEvent 产生的时候，如果ViewGroup中的View消费（返回true），就将这个View记录下来。<strong>后续这一个事件流都直接交给它处理。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3998756-a49851c137ad3679.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件分发机制-简图.png"></p>
<p>其实只有 ACTION_DOWN 事件需要返回 true，其后的像 UP啊，Move啊，他们的返回值并没有什么影响，但是还是推荐都写成true，降低维护成本。</p>
<p>当情况复杂，比如说你现在操作的是列表，点一下会触发点击事件，滑一下就会滑动，那么这样的隔着一个View如何实现的呢？这就是依靠着的就是<strong>事件拦截机制</strong>。</p>
<p>我们将这个过程细分，当你触摸的时候（DOWN事件），这个事件其实是先传到Activity、再传到ViewGroup、最终再传到 View，先问问ViewGroup你拦不拦截啊？一层一层的向下问，如果拦截呢，就直接交给他，如果不拦截呢？就直接往下传，直到传到底层的View，底层的View没有拦截方法，直接问他消不消费，不消费，向上分发，问他的ViewGroup是否分发，如果消费就直接交给它消费掉。这样的话，就可以把消费的权力先交给子View，在合适的时候父View可以马上接管过来。</p>
<p>那么滑动的过程呢？就是在DOWN事件发生的时候，先交给子View消费，当出现MOVE事件的时候，列表发现这个是滑动，需要自己处理，就拦截并且消费掉。但是这时候View还等着后续的事件流，就比如说背景风格还是按下状态，那么父View就会发给它一个cancel事件，让他恢复状态，并且后续事件交给拦截的父View来处理。<br><img src="https://upload-images.jianshu.io/upload_images/3998756-7feebdca3bad85fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件分发拦截机制-详细图解"></p>
<h2 id="始于-Activity"><a href="#始于-Activity" class="headerlink" title="始于 Activity"></a>始于 Activity</h2><p>点击事件产生最先传递到当前的Activity，由Acivity的dispatchTouchEvent方法来对事件进行分发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Called to process touch screen events.  You can override this to</span><br><span class="line"> * intercept all touch screen events before they are dispatched to the</span><br><span class="line"> * window.  Be sure to call this implementation for touch screen events</span><br><span class="line"> * that should be handled normally.</span><br><span class="line"> *</span><br><span class="line"> * @param ev The touch screen event.</span><br><span class="line"> *</span><br><span class="line"> * @return boolean Return true if this event was consumed.</span><br><span class="line"> */</span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很简单，我们来一行一行进行解析。最开始，就是就是判断当前这个事件是否是按下这个事件( <code>MotionEvent.ACTION_DOWN</code>)，如果是，就执行一个空方法( <code>onUserInteraction()</code> 等待程序猿大爷重写)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Called whenever a key, touch, or trackball event is dispatched to the</span><br><span class="line"> * activity.  Implement this method if you wish to know that the user has</span><br><span class="line"> * interacted with the device in some way while your activity is running.</span><br><span class="line"> * This callback and &#123;@link #onUserLeaveHint&#125; are intended to help</span><br><span class="line"> * activities manage status bar notifications intelligently; specifically,</span><br><span class="line"> * for helping activities determine the proper time to cancel a notfication.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;All calls to your activity&apos;s &#123;@link #onUserLeaveHint&#125; callback will</span><br><span class="line"> * be accompanied by calls to &#123;@link #onUserInteraction&#125;.  This</span><br><span class="line"> * ensures that your activity will be told of relevant user activity such</span><br><span class="line"> * as pulling down the notification pane and touching an item there.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note that this callback will be invoked for the touch down action</span><br><span class="line"> * that begins a touch gesture, but may not be invoked for the touch-moved</span><br><span class="line"> * and touch-up actions that follow.</span><br><span class="line"> *</span><br><span class="line"> * @see #onUserLeaveHint()</span><br><span class="line"> */</span><br><span class="line">public void onUserInteraction() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里多说几句，这个空方法是在哪些时候会调用呢？毕竟我们也是要重写的嘛，那就必须知道其执行的时期：<strong>activity在分发各种事件的时候会调用该方法，旨在提供帮助Activity智能地管理状态栏通知</strong>。当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法。下拉statubar、旋转屏幕、锁屏不会触发此方法。所以它会用在屏保应用上，因为当你触屏机器，就会立马触发一个事件，而这个事件又不太明确是什么，正好屏保满足此需求；或者对于一个Activity，控制多长时间没有用户点响应的时候，自己消失等。</p>
<p>我们接着往下看<code>getWindow().superDispatchTouchEvent(ev)</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Window getWindow() &#123;</span><br><span class="line">    return mWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接返回当前界面的 mWindow，mWindow 是什么啊，是 Window ，Window 我们都知道，是一个 抽象类，它的唯一实现类就是 PhoneWindow，那我们来点一下 superDispatchTouchEvent(MotionEvent)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Used by custom windows, such as Dialog, to pass the touch screen event</span><br><span class="line"> * further down the view hierarchy. Application developers should</span><br><span class="line"> * not need to implement or call this.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public abstract boolean superDispatchTouchEvent(MotionEvent event);</span><br></pre></td></tr></table></figure></p>
<p>Window 的抽象方法啊，那我们在 PhoneWindow找一找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>哇，实现要不要就这么简单，直接由Window 直接传递给了 mDecor，mDecor是什么啊？是 DecorView。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class DecorView extends FrameLayout implements RootViewSurfaceTaker, </span><br><span class="line">                                                      WindowCallbacks &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DecorView就是Window的顶级View，是一个ViewGroup，我们通过setContentView设置的View是它的子View（Activity的setContentView，最终是调用PhoneWindow的setContentView).</p>
<p>这里放一张 Activity-&gt;视图 的图片<br><img src="https://upload-images.jianshu.io/upload_images/3998756-b2abafc93bd4a608.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity 结构"></p>
<p>是不是简单几步就实现了由Activity到ViewGroup的传递，这个中间传递者呢，就是Window。</p>
<p>上面传递到了 DecorView，他直接调用了 ViewGroup 的<code>dispatchTouchEvent()</code>进行分发了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return super.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在陷入复杂的分发逻辑之前，我们先看 Acivity#dispatchTouchEvent留下的一个尾巴 – 最后这个<code>return onTouchEvent(ev);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Called when a touch screen event was not handled by any of the views</span><br><span class="line"> * under it.  This is most useful to process touch events that happen</span><br><span class="line"> * outside of your window bounds, where there is no view to receive it.</span><br><span class="line"> *</span><br><span class="line"> * @param event The touch screen event being processed.</span><br><span class="line"> *</span><br><span class="line"> * @return Return true if you have consumed the event, false if you haven&apos;t.</span><br><span class="line"> * The default implementation always returns false.</span><br><span class="line"> */</span><br><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    if (mWindow.shouldCloseOnTouch(this, event)) &#123;  // 当超出边界要关闭Window，且超出边界，且顶层的 DecorView 不为空</span><br><span class="line">        finish();    </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;   // 默认情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Activity#onTouchEvent 是我们经常重写的方法，执行了 <code>onTouchEvent</code>表示 <code>getWindow().superDispatchTouchEvent(ev)</code>返回的是 false，我们都知道<strong>在事件分发体系中，true 表示消费了这个事件（处理了这个事件）</strong>，那么onTouchEvent 被调用表示这个事件没有任何View消费，只能交给 Activity 处理，如何处理？就是调用 onTouchEvent 这个方法。</p>
<p>来看一下Window#shouldCloseOnTouch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** @hide */</span><br><span class="line">public boolean shouldCloseOnTouch(Context context, MotionEvent event) &#123;</span><br><span class="line">    final boolean isOutside =</span><br><span class="line">            event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; isOutOfBounds(context, event)</span><br><span class="line">            || event.getAction() == MotionEvent.ACTION_OUTSIDE;</span><br><span class="line">    if (mCloseOnTouchOutside &amp;&amp; peekDecorView() != null &amp;&amp; isOutside) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里判断mCloseOnTouchOutside标记及是否为ACTION_DOWN事件，同时判断event的x、y坐标是不是超出Bounds，然后检查FrameLayout的content的id的DecorView是否为空，进行简单判断，由此决定是否销毁这个 Activity。</p>
<p>到这里 Activity 这一层就分析完了。我们在这里理一下：</p>
<ol>
<li>先判断是否是按下事件，是则 调用<code>onUserInteraction();</code>空方法</li>
<li>在 if 括号中分发，首先是交给Activity上的 Window，Window交给顶级视图 DecorView，DecorView 调用父类 ViewGroup#dispatchTouchEvent 进行分发。</li>
<li>如果在分发结束后，没人消费这个事件，就调用Activity#onTouchEvent 进行处理，处理得很简单，就是判断是否需要超出边界就销毁当前的Activity，需要且超出边界就finish 并且返回true，默认为false。</li>
</ol>
<h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><p>书接上文，当我们将事件交给 ViewGroup#dispatchTouchEvent ，那他怎么处理的呢？</p>
<p>真的可以说是超级长了，墙裂推荐使用编辑器看。还有就是看注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        // 检查合法性代码省略</span><br><span class="line"></span><br><span class="line">        boolean handled = false;  // 是否消费</span><br><span class="line">        if (onFilterTouchEventForSecurity(ev)) &#123; // 以安全策略判断是否可以分发，true-&gt;可以分发</span><br><span class="line">            final int action = ev.getAction();  // 事件动作  不同的位存储有不同的信息</span><br><span class="line">            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;  // 事件类型</span><br><span class="line"></span><br><span class="line">            // 注释1</span><br><span class="line">            // Handle an initial down.  处理第一次按下  </span><br><span class="line">            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                // Throw away all previous state when starting a new touch gesture.</span><br><span class="line">                // The framework may have dropped the up or cancel event for the previous gesture</span><br><span class="line">                // due to an app switch, ANR, or some other state change.</span><br><span class="line">                cancelAndClearTouchTargets(ev);  // 将当前事件分发下去，并且将整个TouchTarget链表回收</span><br><span class="line">                resetTouchState();  // 重置Touch状态标识</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Check for interception.  标记ViewGroup是否拦截Touch事件的传递</span><br><span class="line">            final boolean intercepted;</span><br><span class="line">            if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != null) &#123;  // 当事件是按下或者已经找到能够接收touch事件的目标组件</span><br><span class="line">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;  // 是否禁止拦截  注释2</span><br><span class="line">                if (!disallowIntercept) &#123;  // 如果自己可以拦截，默认可以</span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);  // 注释3 默认不拦截，用于重写</span><br><span class="line">                    ev.setAction(action); // restore action in case it was changed</span><br><span class="line">                &#125; else &#123;  // 不可以拦截，直接将intercepted 设置为false</span><br><span class="line">                    intercepted = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;  // 注意，重点，当不是事件序列开始，而且还没有设置分发的子View，那么只有一种可能，就是在这之前就被我自己拦截过了，后续序列我默认拦截消费</span><br><span class="line">                // There are no touch targets and this action is not an initial down</span><br><span class="line">                // so this view group continues to intercept touches.</span><br><span class="line">                // 不是事件流开始的 ACTION_DOWN，也没有事件流的消费组件，那么直接拦截。</span><br><span class="line">                intercepted = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If intercepted, start normal event dispatch. Also if there is already</span><br><span class="line">            // a view that is handling the gesture, do normal event dispatch.</span><br><span class="line">            if (intercepted || mFirstTouchTarget != null) &#123;</span><br><span class="line">                ev.setTargetAccessibilityFocus(false);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Check for cancelation. 检查 cancel 事件</span><br><span class="line">            final boolean canceled = resetCancelNextUpFlag(this)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">            // 开始事件分发</span><br><span class="line">            // Update list of touch targets for pointer down, if needed.</span><br><span class="line">            // 是否把事件分发给多个子View，设置： ViewGroup#setMotionEventSplittingEnabled</span><br><span class="line">            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</span><br><span class="line">            TouchTarget newTouchTarget = null;  // 用于存储已经是事件流承受者的TargetView（在mFirstTouchTarget 这个事件流消费者链表中）</span><br><span class="line">            boolean alreadyDispatchedToNewTouchTarget = false;</span><br><span class="line">            if (!canceled &amp;&amp; !intercepted) &#123;  // 不取消，不拦截，就分发</span><br><span class="line"></span><br><span class="line">                // If the event is targeting accessiiblity focus we give it to the</span><br><span class="line">                // view that has accessibility focus and if it does not handle it</span><br><span class="line">                // we clear the flag and dispatch the event to all children as usual.</span><br><span class="line">                // We are looking up the accessibility focused host to avoid keeping</span><br><span class="line">                // state since these events are very rare.</span><br><span class="line">                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                        ? findChildWithAccessibilityFocus() : null;</span><br><span class="line"></span><br><span class="line">                // 处理ACTION_DOWN事件</span><br><span class="line">                if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                    final int actionIndex = ev.getActionIndex(); // always 0 for down</span><br><span class="line">                    // 当前 MotionEvent 的动作标识</span><br><span class="line">                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)   </span><br><span class="line">                            : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                    // Clean up earlier touch targets for this pointer id in case they</span><br><span class="line">                    // have become out of sync.</span><br><span class="line">                    removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                    final int childrenCount = mChildrenCount;   // 子View数量</span><br><span class="line">                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;  // 有子View可分发</span><br><span class="line">                        final float x = ev.getX(actionIndex);  // 得到点击的X坐标</span><br><span class="line">                        final float y = ev.getY(actionIndex);  // 得到y坐标</span><br><span class="line">                        // Find a child that can receive the event.</span><br><span class="line">                        // Scan children from front to back.</span><br><span class="line">                        final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();  // 子View的集合 注释4（顺序问题）</span><br><span class="line">                        final boolean customOrder = preorderedList == null</span><br><span class="line">                                &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                        final View[] children = mChildren;  // 也是所有子View</span><br><span class="line">                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;  // 倒序访问</span><br><span class="line">                            final int childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                    childrenCount, i, customOrder);  // 得到下标，正常情况下就是 i</span><br><span class="line">                            final View child = getAndVerifyPreorderedView(</span><br><span class="line">                                    preorderedList, children, childIndex);  // 取出 i 对用的View</span><br><span class="line"></span><br><span class="line">                            // If there is a view that has accessibility focus we want it</span><br><span class="line">                            // to get the event first and if not handled we will perform a</span><br><span class="line">                            // normal dispatch. We may do a double iteration but this is</span><br><span class="line">                            // safer given the timeframe.</span><br><span class="line">                            if (childWithAccessibilityFocus != null) &#123;</span><br><span class="line">                                if (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                    continue;</span><br><span class="line">                                &#125;</span><br><span class="line">                                childWithAccessibilityFocus = null;</span><br><span class="line">                                i = childrenCount - 1;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            if (!canViewReceivePointerEvents(child)   //  注意，这就是主要的筛选条件：1. 能不能接收事件（不可见或者在动画）</span><br><span class="line">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;  // 2. 是不是在他的范围内</span><br><span class="line">                                ev.setTargetAccessibilityFocus(false);</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                           // 注释5 如果在 mFirstTouchTarget中，就返回当前这个封装了child 的 TouchTarget，没有就返回null（注意，这时候这个View已经是在）</span><br><span class="line">                            newTouchTarget = getTouchTarget(child); </span><br><span class="line">                            if (newTouchTarget != null) &#123;   // 在mFirstTouchTarget 这个事件流消费者链表中，找到事件流的消费者，跳出循环</span><br><span class="line">                                // Child is already receiving touch within its bounds.</span><br><span class="line">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                                break;    // 像UP、MOVE等事件就是从这里跳出循环的</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            resetCancelNextUpFlag(child);  // 重置flag：cancel next up</span><br><span class="line">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;  // 注释6 重中之重  就是这里分发，看子View是否消费</span><br><span class="line">                                // Child wants to receive touch within its bounds. 如果消费了</span><br><span class="line">                                mLastTouchDownTime = ev.getDownTime();  // 更新按下事件</span><br><span class="line">                                if (preorderedList != null) &#123;</span><br><span class="line">                                    // childIndex points into presorted list, find original index </span><br><span class="line">                                  // 找到在ViewGroup 中存储的child，最原始的下标</span><br><span class="line">                                    for (int j = 0; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                        if (children[childIndex] == mChildren[j]) &#123; </span><br><span class="line">                                            mLastTouchDownIndex = j;  // 找到ViewGroup 中的数组的原始下标，保存在ViewGroup的成员变量中</span><br><span class="line">                                            break;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; else &#123;   // 临时的排过序的数组为null</span><br><span class="line">                                    mLastTouchDownIndex = childIndex;   </span><br><span class="line">                                &#125;</span><br><span class="line">                                mLastTouchDownX = ev.getX();  // 被消费的事件流的DOWN事件的触摸点X（起点x坐标）</span><br><span class="line">                                mLastTouchDownY = ev.getY();  // 起点y坐标</span><br><span class="line">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);   // 将消费事件流的子View的父View（当前ViewGroup）记录在消费的链表头  插入操作可见注释7</span><br><span class="line">                                alreadyDispatchedToNewTouchTarget = true;  // 表示已经成功分发给自己的子View</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            // The accessibility focus didn&apos;t handle the event, so clear</span><br><span class="line">                            // the flag and do a normal dispatch to all children.</span><br><span class="line">                            ev.setTargetAccessibilityFocus(false);</span><br><span class="line">                        &#125; // for循环结束</span><br><span class="line">                        if (preorderedList != null) preorderedList.clear();</span><br><span class="line">                    &#125;   // 处理是 if (newTouchTarget == null &amp;&amp; childrenCount != 0)，意味着子View不为0并且没有记录的情况下的处理</span><br><span class="line"></span><br><span class="line">                    //  dispatchTransformedTouchEvent方法返回false，意味着子View也不消费</span><br><span class="line">                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</span><br><span class="line">                        // Did not find a child to receive the event.没有child接收事件</span><br><span class="line">                        // Assign the pointer to the least recently added target.</span><br><span class="line">                        newTouchTarget = mFirstTouchTarget;  </span><br><span class="line">                        while (newTouchTarget.next != null) &#123;</span><br><span class="line">                            newTouchTarget = newTouchTarget.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  // DOWN 事件的处理结束</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Dispatch to touch targets.</span><br><span class="line">            if (mFirstTouchTarget == null) &#123;  // 子View不消费</span><br><span class="line">                // No touch targets so treat this as an ordinary view.</span><br><span class="line">                handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);  // 交给自己处理（源码下面有）</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Dispatch to touch targets, excluding the new touch target if we already</span><br><span class="line">                // dispatched to it.  Cancel touch targets if necessary.</span><br><span class="line">                TouchTarget predecessor = null;  </span><br><span class="line">                TouchTarget target = mFirstTouchTarget;  // 头节点</span><br><span class="line">                while (target != null) &#123;</span><br><span class="line">                    final TouchTarget next = target.next;  // 后驱节点</span><br><span class="line">                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;   // 这两个值是在第一次dispatchTransformedTouchEvent的时候返回true赋值的，意味着事件被子View消费</span><br><span class="line">                        handled = true;  // 如果被消费了</span><br><span class="line">                    &#125; else &#123;  </span><br><span class="line">                        // 不分发给子View，意味着被拦截或者子View与父ViewGroup临时视图分离（mPrivateFlags设置了PFLAG_CANCEL_NEXT_UP_EVENT），就向记录在的</span><br><span class="line">                        // 是否分发给子View</span><br><span class="line">                        final boolean cancelChild = </span><br><span class="line">resetCancelNextUpFlag(target.child)</span><br><span class="line">                                || intercepted;   // 当前ViewGroup是否拦截</span><br><span class="line">                        if (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                                target.child, target.pointerIdBits)) &#123;   // 如果不分发分发子View，调用dispatchTransformedTouchEvent发送cancel事件，已经分发过了就排除新的触摸目标</span><br><span class="line">                            handled = true;  // 是否自己或者子View消费</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (cancelChild) &#123;   // 事件不分发给子View，有可能是被拦截了</span><br><span class="line">                            if (predecessor == null) &#123;   // 具体链表操作看 注释8</span><br><span class="line">                                mFirstTouchTarget = next;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                predecessor.next = next;</span><br><span class="line">                            &#125;</span><br><span class="line">                            target.recycle();</span><br><span class="line">                            target = next;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    predecessor = target;</span><br><span class="line">                    target = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Update list of touch targets for pointer up or cancel, if needed.</span><br><span class="line">            if (canceled</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">                final int actionIndex = ev.getActionIndex();</span><br><span class="line">                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">                removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注释1：</strong><br>这里呢，就是当一个 ACTION_DOWN 事件来了以后，需要清除一些以前事件序列的标记，开始下一个事件序列。<strong>在 cancelAndClearTouchTargets(ev) 方法中有一个非常重要的操作就是将mFirstTouchTarget设置为了null</strong>，在resetTouchState()方法中重置Touch状态标识。</p>
<p>mFirstTouchTarget 是 TouchTarget，ViewGroup 的成员变量，<strong>记录要消费整个事件流的View</strong>，一个触摸事件可能有多个View可以接收到,该参数把他们连接成链状。</p>
<p><strong>注释2</strong><br>这里介绍一下几个基础知识，让大家知道为什么有这个事件拦截。</p>
<p>当我们按下的时候，即 <strong>ACTION_DOWN</strong> 发生的时候，标志着整个事件流的开始，这时候我们会<strong>去找整个事件流的处理者</strong>，对应的就是整个事件分发流程，一旦<strong>找到</strong>这个事件流的处理者（消费了这个事件的ACTION_DOWN），那么<strong>后续的整个事件流都会直接发送</strong>给这个处理者进行消费掉。</p>
<p>就比如说屏幕上有一个button，我滑动一下按钮，则从 ACTION_DOWN 的时候找到消费这个事件的组件了，然后button表现出按下状态。而后续整个 ACTION_MOVE  事件和 ACTION_UP 事件都直接发送给这个button处理。当下一个事件流来到又重复上述过程。</p>
<p>当情况变复杂的时候，比如说是列表，首先一来就是一个 ACTION_DOWN 事件，可是我也不知道他是点击还是按下啊，所以只能分发下去，交给了item消费了，<strong>可是我发现他是滑动事件，那么我就要从子View 中把消费事件的权利抢过来，就是拦截了</strong>。而item呢？还是一个按下状态，就发送一个 ACTION_CANCEL 事件给他让他恢复状态。这里呢，意思就是说，<strong>当一个事件流我交给子View消费过后，后续不再分发给我，但是在整个事件流处理过程中，我可以随时拦截，交给我来处理</strong>。</p>
<p>而假如我是子View，我又不希望我的ViewGroup拦截怎么办呢？当然有办法：ViewGroup#requestDisallowInterceptTouchEvent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;</span><br><span class="line"></span><br><span class="line">    if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123;   </span><br><span class="line">        // We&apos;re already in this state, assume our ancestors are too</span><br><span class="line">        // 已经处于这种状态</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (disallowIntercept) &#123;</span><br><span class="line">        mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Pass it up to our parent</span><br><span class="line">    if (mParent != null) &#123;</span><br><span class="line">        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很简单，设置 ViewGroup的标志位，并递归告诉父ViewGroup不要拦截。</p>
<p><strong>注释3</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在当前ViewGroup可以拦截的情况下，看自己拦不拦截呢？不拦截，鼠标那个事件就不考虑了，看到没有，<strong>默认返回false，不拦截</strong>。当然这个方法主要也是用于我们重写。</p>
<p><strong>注释4</strong><br>preorderedList中的顺序：按照addView或者XML布局文件中的顺序来的，后addView添加的子View，会添加在列表的后面，会因为Android的UI后刷新机制显示在上层；</p>
<p>在事件分发的时候倒序遍历分发，那么最上层的View就可以最先接收到这个事件流，并决定是否消费这个事件流。</p>
<p><strong>注释5</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Gets the touch target for specified child view.</span><br><span class="line"> * Returns null if not found.</span><br><span class="line"> */</span><br><span class="line">private TouchTarget getTouchTarget(@NonNull View child) &#123;</span><br><span class="line">    for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) &#123;</span><br><span class="line">        if (target.child == child) &#123;</span><br><span class="line">            return target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里我们可以很清楚的明白，首先存储消费事件的目标组件的数据结构是链表，其次 mFirstTouchTarget 就是头节点。而 getTouchTarget 就是遍历整个链表，如果有就返回这个TouchTarget，没有就返回null，最后返回的值存储在 newTouchTarget 中。</p>
<p>这里我们介绍一下 TouchTarget ，TouchTarget 作为 ViewGroup 的内部类，原理很像Message的原理。<a href="https://www.jianshu.com/p/267c14083cc6" target="_blank" rel="noopener">Android 的消息机制 介绍传送门</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/* Describes a touched view and the ids of the pointers that it has captured.</span><br><span class="line"> *</span><br><span class="line"> * This code assumes that pointer ids are always in the range 0..31 such that</span><br><span class="line"> * it can use a bitfield to track which pointer ids are present.</span><br><span class="line"> * As it happens, the lower layers of the input dispatch pipeline also use the</span><br><span class="line"> * same trick so the assumption should be safe here...</span><br><span class="line"> */</span><br><span class="line">private static final class TouchTarget &#123;</span><br><span class="line">    private static final int MAX_RECYCLED = 32;  // 回收池最大容量</span><br><span class="line">    private static final Object sRecycleLock = new Object[0];  // 回收时候同步控制需要持有的对象锁</span><br><span class="line">    private static TouchTarget sRecycleBin; // 回收池的头节点，注意是 static</span><br><span class="line">    private static int sRecycledCount;  // 当前回收池的数量</span><br><span class="line"></span><br><span class="line">    public static final int ALL_POINTER_IDS = -1; // all ones</span><br><span class="line"></span><br><span class="line">    // The touched child view.</span><br><span class="line">    public View child;   //存储的数据：View。整个事件流的消费者</span><br><span class="line"></span><br><span class="line">    // The combined bit mask of pointer ids for all pointers captured by the target.</span><br><span class="line">    public int pointerIdBits; </span><br><span class="line"></span><br><span class="line">    // The next target in the target list.</span><br><span class="line">    public TouchTarget next;   //下一个节点</span><br><span class="line"></span><br><span class="line">    private TouchTarget() &#123;  // 不能在外部new出来</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将传入的数据封装成一个TouchTarget链表的结点</span><br><span class="line">    public static TouchTarget obtain(@NonNull View child, int pointerIdBits) &#123;</span><br><span class="line">        if (child == null) &#123;  // 需要传入封装的对象吖</span><br><span class="line">            throw new IllegalArgumentException(&quot;child must be non-null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final TouchTarget target;  // 最后构建出来存储的链表节点</span><br><span class="line">        synchronized (sRecycleLock) &#123;  // 拿到同步锁</span><br><span class="line">            if (sRecycleBin == null) &#123;</span><br><span class="line">                target = new TouchTarget();  // 回收池为空，直接内部new出来</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                target = sRecycleBin;   // 将头节点作为目标节点</span><br><span class="line">                sRecycleBin = target.next;   // 将头节点下移一个</span><br><span class="line">                 sRecycledCount--;   // 回收池数量减一</span><br><span class="line">                target.next = null;  // 将取出的节点与链表的联系断掉</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        target.child = child;  // 装进节点</span><br><span class="line">        target.pointerIdBits = pointerIdBits;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提供回收当前节点的方法</span><br><span class="line">    public void recycle() &#123;  </span><br><span class="line">        if (child == null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;already recycled once&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (sRecycleLock) &#123;  // 拿到同步锁</span><br><span class="line">            if (sRecycledCount &lt; MAX_RECYCLED) &#123;  // 没有超过回收池容量</span><br><span class="line">                next = sRecycleBin;  // 当前回收节点指向回收池链表的头结点</span><br><span class="line">                sRecycleBin = this;  // 回收池头结点指向自己，相当于上移</span><br><span class="line">                sRecycledCount += 1;  // 数量加1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                next = null;  // 置空，help Gc</span><br><span class="line">            &#125;</span><br><span class="line">            child = null;  // 抹除记录的数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然最后是一条以为头结点的链表，那么他到底存的是哪些View呢？上一张图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3998756-38f7a55f6928b8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mFirstTouchTarget 链表"></p>
<p>当我们按下 button2 的时候，会一层一层的传下去，最下层的消费了，然后返回上层接着执行代码（方法调用的时候是当前方法就被压入栈中，调用方法执行结束再弹出执行），上层会在 <code>if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign))</code>的时候得到true，将刚刚消费的子View（ViewGroup/View）记录进链表。</p>
<p><strong>注释6</strong><br>下面就是在第一次什么都没有的时候进行分发，注意哦，这里还在循环里面，就意味着这次循环没找到记录，并且触摸点在这个ViewGroup范围内，可见，那我就分发。</p>
<p>接下来详细看一下ViewGroup#dispatchTransformedTouchEvent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Transforms a motion event into the coordinate space of a particular child view,</span><br><span class="line"> * filters out irrelevant pointer ids, and overrides its action if necessary.</span><br><span class="line"> * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.</span><br><span class="line"> */</span><br><span class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</span><br><span class="line">        View child, int desiredPointerIdBits) &#123;</span><br><span class="line">    final boolean handled;  // 是否消费</span><br><span class="line"></span><br><span class="line">    // Canceling motions is a special case.  We don&apos;t need to perform any transformations</span><br><span class="line">    // or filtering.  The important part is the action, not the contents.</span><br><span class="line">    final int oldAction = event.getAction();  // 获取当前事件</span><br><span class="line">    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;  // 取消，或者是取消事件</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        if (child == null) &#123;  // 传进来的子View为空</span><br><span class="line">            handled = super.dispatchTouchEvent(event);  // 当前ViewGroup 来执行，调用的是父类View的方法</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);  // 直接交给传进来的子View，在这里就是循环的时候倒序获取的View</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);  // 设置为 ACTION_CANCEL</span><br><span class="line">        return handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Calculate the number of pointers to deliver.计算要传递的指针数。</span><br><span class="line">    final int oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    // If for some reason we ended up in an inconsistent state where it looks like we</span><br><span class="line">    // might produce a motion event with no pointers in it, then drop the event.</span><br><span class="line">    if (newPointerIdBits == 0) &#123;  // 异常情况，放弃处理</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the number of pointers is the same and we don&apos;t need to perform any fancy</span><br><span class="line">    // irreversible transformations, then we can reuse the motion event for this</span><br><span class="line">    // dispatch as long as we are careful to revert any changes we make.</span><br><span class="line">    // Otherwise we need to make a copy.</span><br><span class="line">    final MotionEvent transformedEvent;</span><br><span class="line">    if (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        if (child == null || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">                handled = super.dispatchTouchEvent(event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                final float offsetX = mScrollX - child.mLeft;</span><br><span class="line">                final float offsetY = mScrollY - child.mTop;</span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line">            return handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Perform any necessary transformations and dispatch.</span><br><span class="line">    if (child == null) &#123;</span><br><span class="line">        handled = super.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final float offsetX = mScrollX - child.mLeft;</span><br><span class="line">        final float offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        if (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Done.</span><br><span class="line">    transformedEvent.recycle();   // 回收TouchTarget</span><br><span class="line">    return handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里引用大神的分析：</p>
<p>在dispatchTouchEvent()中多次调用了dispatchTransformedTouchEvent()方法，而且有时候第三个参数为null，有时又不是，他们到底有啥区别呢？这段源码中很明显展示了结果。在<code>dispatchTransformedTouchEvent()</code>源码中可以发现多次对于child是否为null的判断，并且均做出如下类似的操作。其中，当<code>child == null</code>时会将Touch事件传递给该ViewGroup自身的dispatchTouchEvent()处理，即<code>super.dispatchTouchEvent(event)</code>（也就是View的这个方法，因为ViewGroup的父类是View）；当child != null时会调用该子view(当然该view可能是一个View也可能是一个ViewGroup)的dispatchTouchEvent(event)处理，即<code>child.dispatchTouchEvent(event)</code>。别的代码几乎没啥需要具体注意分析的。</p>
<p>具体的什么时候会传空呢，我们接着往下看，后面会分析和总结。</p>
<p><strong>注释7</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Adds a touch target for specified child to the beginning of the list.</span><br><span class="line"> * Assumes the target child is not already present.</span><br><span class="line"> */</span><br><span class="line">private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123;</span><br><span class="line">    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);  // 获取节点，并将数据装进去</span><br><span class="line">    target.next = mFirstTouchTarget;  // 将新节点的next指向下一个节点</span><br><span class="line">    mFirstTouchTarget = target;   // 头结点记录为当前节点</span><br><span class="line">    return target;   // 返回头节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，整个 ViewGroup 层就结束啦，这里来总结下，<code>dispatchTransformedTouchEvent()</code>什么时候会传入一个null的child呢？</p>
<ul>
<li>ViewGroup 没有子View</li>
<li>子元素处理了点击事件，但是在 dispatchTouchEvent 中返回了false，这一般都是因为子 View 在onTouchEvent 中返回了 false。</li>
</ul>
<p><strong>注释8</strong><br>这里主要分析的是循环中的链表操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">while (target != null) &#123;</span><br><span class="line">    final TouchTarget next = target.next;</span><br><span class="line">    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">        handled = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final boolean cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                || intercepted;</span><br><span class="line">        if (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                target.child, target.pointerIdBits)) &#123;</span><br><span class="line">            handled = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cancelChild) &#123;</span><br><span class="line">            if (predecessor == null) &#123;</span><br><span class="line">                mFirstTouchTarget = next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                predecessor.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            target.recycle();</span><br><span class="line">            target = next;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    predecessor = target;</span><br><span class="line">    target = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="View-最后可能接收到进行消费"><a href="#View-最后可能接收到进行消费" class="headerlink" title="View 最后可能接收到进行消费"></a>View 最后可能接收到进行消费</h2><p>我们知道前面按着正常情况下，就是调用View的dispatchTouchEvent方法，将事件传递给子View，接下来就是View的show time。</p>
<p>View#dispatchTouchEvent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Pass the touch screen motion event down to the target view, or this</span><br><span class="line"> * view if it is the target.</span><br><span class="line"> * 传递给目标View 或者 查看它是否是目标</span><br><span class="line"> *</span><br><span class="line"> * @param event The motion event to be dispatched.</span><br><span class="line"> * @return True if the event was handled by the view, false otherwise.</span><br><span class="line"> */</span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    // If the event should be handled by accessibility focus first.</span><br><span class="line">    if (event.isTargetAccessibilityFocus()) &#123;  // 可访问焦点优先处理</span><br><span class="line">        // We don&apos;t have focus or no virtual descendant has it, do not handle the event.</span><br><span class="line">        if (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // We have focus and got the event, then use normal event dispatch.</span><br><span class="line">        event.setTargetAccessibilityFocus(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean result = false;  // 是否被处理、消费</span><br><span class="line"></span><br><span class="line">    if (mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int actionMasked = event.getActionMasked();</span><br><span class="line">    if (actionMasked == MotionEvent.ACTION_DOWN) &#123;  // 当按下事件发生</span><br><span class="line">        // Defensive cleanup for new gesture</span><br><span class="line">        stopNestedScroll();   // 停止嵌套滚动</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (onFilterTouchEventForSecurity(event)) &#123;   // 根据参数确定是否可以分发：这是一种安全策略（正常情况况下为true）</span><br><span class="line">        if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; </span><br><span class="line">                  handleScrollBarDragging(event)) &#123;  // 作为滚动条拖动就直接处理滚动事件，并直接消费，返回true</span><br><span class="line">            result = true;   // 滚动条的时候</span><br><span class="line">        &#125;</span><br><span class="line">        //noinspection SimplifiableIfStatement </span><br><span class="line">        ListenerInfo li = mListenerInfo;   // 各种listener定义在一起的静态内部类，包括我们熟悉的 onClickListener</span><br><span class="line">        if (li != null &amp;&amp; li.mOnTouchListener != null   </span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED    // 验证 li 中的 mOnTouchListener 不为空，可以调用</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;     // 调用onTouch 方法</span><br><span class="line">            result = true;   // onTouch返回true就消费</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!result &amp;&amp; onTouchEvent(event)) &#123;   // onTouch 不消费就交给onTouchEvent，消费就变true</span><br><span class="line">            result = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123;  </span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Clean up after nested scrolls if this is the end of a gesture;</span><br><span class="line">    // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest</span><br><span class="line">    // of the gesture.</span><br><span class="line">    if (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">            actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看着注释基本都可以看懂，但是这里又一个东西得看一下，方便对一些事件的理解，那就是 onTouchEvent 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Implement this method to handle touch screen motion events.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * If this method is used to detect click actions, it is recommended that</span><br><span class="line"> * the actions be performed by implementing and calling</span><br><span class="line"> * &#123;@link #performClick()&#125;. This will ensure consistent system behavior,</span><br><span class="line"> * including:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;obeying click sound preferences</span><br><span class="line"> * &lt;li&gt;dispatching OnClickListener calls</span><br><span class="line"> * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when</span><br><span class="line"> * accessibility features are enabled</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param event The motion event.</span><br><span class="line"> * @return True if the event was handled, false otherwise.</span><br><span class="line"> */</span><br><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    final float x = event.getX();  // 获取点击坐标</span><br><span class="line">    final float y = event.getY();</span><br><span class="line">    final int viewFlags = mViewFlags;  </span><br><span class="line">    final int action = event.getAction();  // 获取Action类型</span><br><span class="line"></span><br><span class="line">    final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;  // 是否是可点击状态</span><br><span class="line"></span><br><span class="line">    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</span><br><span class="line">            setPressed(false);</span><br><span class="line">        &#125;</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">        // A disabled view that is clickable still consumes the touch</span><br><span class="line">        // events, it just doesn&apos;t respond to them.</span><br><span class="line">        return clickable;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mTouchDelegate != null) &#123;</span><br><span class="line">        if (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">        switch (action) &#123;</span><br><span class="line">            case MotionEvent.ACTION_UP:   // 抬起的时候</span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">                    handleTooltipUp();   // 处理弹窗类型的抬起事件</span><br><span class="line">                &#125;</span><br><span class="line">                if (!clickable) &#123;  // 如果不可点击，移除相关接口设置和设置不可点击，并跳出选择</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    mInContextButtonPress = false;</span><br><span class="line">                    mHasPerformedLongPress = false;</span><br><span class="line">                    mIgnoreNextUpEvent = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;</span><br><span class="line">                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;</span><br><span class="line">                    // take focus if we don&apos;t have it already and we should in</span><br><span class="line">                    // touch mode.</span><br><span class="line">                    boolean focusTaken = false;</span><br><span class="line">                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                        focusTaken = requestFocus();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (prepressed) &#123;</span><br><span class="line">                        // The button is being released before we actually</span><br><span class="line">                        // showed it as pressed.  Make it show the pressed</span><br><span class="line">                        // state now (before scheduling the click) to ensure</span><br><span class="line">                        // the user sees it.</span><br><span class="line">                        // 标志着被按下，背景风格转化为按下状态</span><br><span class="line">                        setPressed(true, x, y);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        // This is a tap, so remove the longpress check</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        // Only perform take click actions if we were in the pressed state 如果我们处于按下状态，则仅执行点击操作</span><br><span class="line">                        if (!focusTaken) &#123;</span><br><span class="line">                            // Use a Runnable and post this rather than calling</span><br><span class="line">                            // performClick directly. This lets other visual state</span><br><span class="line">                            // of the view update before click actions start.</span><br><span class="line">                            if (mPerformClick == null) &#123;</span><br><span class="line">                                mPerformClick = new PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (!post(mPerformClick)) &#123;  // post到主线程执行这个Runnable，这Runnable是由View实现，内部调用li.mOnClickListener.onClick(this);</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (mUnsetPressedState == null) &#123;</span><br><span class="line">                        mUnsetPressedState = new UnsetPressedState();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (prepressed) &#123;  </span><br><span class="line">                        postDelayed(mUnsetPressedState,</span><br><span class="line">                                ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                    &#125; else if (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                        // If the post failed, unpress right now</span><br><span class="line">                        mUnsetPressedState.run();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                &#125;</span><br><span class="line">                mIgnoreNextUpEvent = false;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case MotionEvent.ACTION_DOWN:  // 按下状态</span><br><span class="line">                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;</span><br><span class="line">                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;</span><br><span class="line">                &#125;</span><br><span class="line">                mHasPerformedLongPress = false;</span><br><span class="line"></span><br><span class="line">                if (!clickable) &#123;  // 不是点击的话，有可能就是长按</span><br><span class="line">                    checkForLongClick(0, x, y);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.</span><br><span class="line">                boolean isInScrollingContainer = isInScrollingContainer();</span><br><span class="line"></span><br><span class="line">                // For views inside a scrolling container, delay the pressed feedback for</span><br><span class="line">                // a short period in case this is a scroll.</span><br><span class="line">                if (isInScrollingContainer) &#123;</span><br><span class="line">                    mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                    if (mPendingCheckForTap == null) &#123;</span><br><span class="line">                        mPendingCheckForTap = new CheckForTap();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingCheckForTap.x = event.getX();</span><br><span class="line">                    mPendingCheckForTap.y = event.getY();</span><br><span class="line">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Not inside a scrolling container, so show the feedback right away  视图不是在滚动中，就把自己变为按下状态</span><br><span class="line">                    setPressed(true, x, y);   // 按下状态，为点击事件做准备</span><br><span class="line">                    checkForLongClick(0, x, y);  // 为长按做准备</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case MotionEvent.ACTION_CANCEL:  // 恢复默认状态</span><br><span class="line">                if (clickable) &#123;</span><br><span class="line">                    setPressed(false);  // 恢复默认背景风格</span><br><span class="line">                &#125;</span><br><span class="line">                removeTapCallback();</span><br><span class="line">                removeLongPressCallback();</span><br><span class="line">                mInContextButtonPress = false;</span><br><span class="line">                mHasPerformedLongPress = false;</span><br><span class="line">                mIgnoreNextUpEvent = false;</span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                if (clickable) &#123;</span><br><span class="line">                    drawableHotspotChanged(x, y);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Be lenient about moving outside of buttons</span><br><span class="line">                if (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                    // Outside button</span><br><span class="line">                    // Remove any future long press/tap checks</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</span><br><span class="line">                        setPressed(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的流程最后都可以归结到这张图上</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3998756-7feebdca3bad85fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件分发拦截机制-详细图解"><br>整个事件传递就这样结束了，在这个过程中，拦截分发的代码交错在一起，我这里总结一下流程：</p>
<ol>
<li><p>事件分发开始于Activity#dispatchTouchEvent，先交给getWindow().superDispatchTouchEvent(ev)，返回false再交给Activity#onTouchEvent(ev)</p>
</li>
<li><p>在 PhoneWindow()#superDispatchTouchEvent(ev) 中，直接交给了顶层View：DecorView#superDispatchTouchEvent</p>
</li>
<li><p>在 DecorView#superDispatchTouchEvent 直接 super.dispatchTouchEvent(event)，意味着调用父类ViewGroup#dispatchTouchEvent 处理。</p>
</li>
<li><p>调用 ViewGroup#onInterceptTouchEvent 判断是否拦截</p>
<blockquote>
<p>如果拦截，就super. </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>如果不拦截并且是事件流的开始的话（DOWN 事件），就调用ViewGroup#dispatchTransformedTouchEven 分发下去</p>
<blockquote>
<p>如果分发成功，就将分发成功的View存在 mFirstTouchTarget 链表中 </p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如果遍历分发，没人消费，或没有子View的话，就调用父类（也是View啊）的 dispatchTouchEvent，这里面就会执行onTouch / onTouchEvent 方法</p>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/03/View的事件分发拦截机制/" data-id="ck1aha3e90001osvzg39xc5pm"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Framework/">Framework</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2019/10/03/Android的消息机制-Handler/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            Android的消息机制-Handler
          
        </div>
      </a>
    
    
      <a href="/2019/10/02/hello-world/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">Hello World</div>
      </a>
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: '7fe0aa956b684f67dc71',
      clientSecret: '6d1c739bf59040f4fa8b09bf4bebcfa7ed9d1cea',
      repo: 'rhine-li-lei.github.io',
      owner: 'rhine-li-lei',
      admin: ['rhine-li-lei'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 rhine(黎磊)</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

<aside class="sidebar sidebar-specter">
  
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/ProfilePicture.jpg" alt="rhine(黎磊)"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>