<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Android的消息机制-Handler |
    
    rhine(黎磊)</title>
  
    <link rel="shortcut icon" href="/images/ProfilePicture.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  

<article id="post-Android的消息机制-Handler" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android的消息机制-Handler
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2018/07/26/Android的消息机制-Handler/" class="article-date">
  <time datetime="2018-07-25T17:41:19.000Z" itemprop="datePublished">2018-07-26</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android系列/">Android系列</a>
  </div>

      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>为了更好的理解 Looper 的工作原理，我们需要对 ThreadLocal 进行了解，如果对 ThreadLocal 没有了解的童鞋，可以参看  <a href="https://www.jianshu.com/p/0ba78fe61c40" target="_blank" rel="noopener">ThreadLocal 原理</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>  一句话原理：<strong>共享内存</strong></p>
<p>  Handler 作为日常开发的必备，不可避免就要涉及这方面的知识。从开发者角度来说，<strong>Handler 是 Android 消息机制的上层接口</strong>，使得开发的时只需与 Handler 交互即可。Handler 使用也很简单，<strong>能够轻松将一个任务切换到 Handler 所在的线程中执行</strong>。</p>
<p>很多人认为Handler的作用就是更新UI，的确没错，但是更新UI仅仅是Handler的一个特殊的使用场景。具体来说，就是有时候需要在子线程做一些耗时操作，比如说访问网络或者耗时的I/O操作，当这些耗时操作完成时，程序的UI进行相应的改变。由于安卓开发规范的限制，我们不能在子线程中访问UI控件，因为UI的控件是线程非安全的，这个时候通过Handler就可以将更新UI的操作切换到主线程中执行。<br><a id="more"></a><br>Android 的消息机制主要是指 Handler 的运行机制。事实上，Handler，Looper，MessageQueue 是一套运行体制而出现的，<strong>MessageQueue</strong> 是一个消息队列，<strong>以队列形式提供插入和删除，主要用于消息的存储，内部实现是采用单链表的形式来组织 Message。</strong>而 <strong>Looper 用于处理消息</strong>，Looper 内部会以无限循环去查是否有新的 Message ，有则处理，没有就等待。需要特殊说明的是，Looper 内部是使用 ThreadLocal 实现的，由于ThreadLocal 可以在每一个线程中互不干扰的存取数据，所以通过ThreadLocal 就可以轻松获取每个线程的 Looper。</p>
<p>Message ：android.os.Message是定义一个Messge包含必要的描述和属性数据，并且此对象可以被发送给android.os.Handler处理。属性字段：arg1、arg2、what、obj、replyTo等；其中arg1和arg2是用来存放整型数据的；what是用来保存消息标示的；obj是Object类型的任意对象；replyTo是消息管理器，会关联到一个handler，handler就是处理其中的消息。通常对Message对象不是直接new出来的，只要调用handler中的obtainMessage方法来直接获得Message对象。</p>
<p>需要特殊说明的是，<strong>线程是默认没有 Looper 的</strong>，如果需要使用 Handler 就必须为线程创建Looper，但是APP 的主线程中，即 ActivityThread ，在主线程被创建的时候就会初始化 Looper。另外，在没有Looper 的线程创建 Handler 也会失败。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3998756-3adfd5910e1e6f84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler 工作过程"><br><img src="https://upload-images.jianshu.io/upload_images/3998756-96c14e3433511788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hnadler 的工作流程"></p>
<h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>话不多说，上例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private TextView textView;</span><br><span class="line">    private String TAG = &quot;MainActivity&quot;;</span><br><span class="line">    private int i = 0;</span><br><span class="line"></span><br><span class="line">    Handler mHandler = new Handler()&#123;</span><br><span class="line">        /**</span><br><span class="line">         * handleMessage接收消息后进行相应的处理</span><br><span class="line">         * @param msg</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">            if(msg.what==1)&#123;</span><br><span class="line">                textView.setText(msg.arg1+&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">    &#125;</span><br><span class="line">    public void onClick(View v)&#123;</span><br><span class="line">        ++i;</span><br><span class="line">        //创建新的线程</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                doSendMsg();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在子线程中做耗时操作，完成之后，通知Handler更新UI</span><br><span class="line">     */</span><br><span class="line">    private void doSendMsg()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);//模拟耗时操作</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.arg1 = i;</span><br><span class="line">        message.what = 1;</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>代码版本 ： Android API25</p>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><h3 id="生成一个-Message"><a href="#生成一个-Message" class="headerlink" title="生成一个 Message"></a>生成一个 Message</h3><p>前面讲过 Message 通常不是 new 出来的，而是通过调用 Handler 的obtainMessage() 得到一个新的 Message：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final Message obtainMessage()</span><br><span class="line">   &#123;</span><br><span class="line">       return Message.obtain(this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>而 Handler 就调用 Message 的 obtain(Handler h) 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public final class Message implements Parcelable &#123;</span><br><span class="line">   </span><br><span class="line">    public int what;  // 让接收者知道这是什么</span><br><span class="line">    public int arg1;  // 存储 int 用于传递过去</span><br><span class="line">    public int arg2;  </span><br><span class="line">    public Object obj;  // 传递一个对象过去</span><br><span class="line">    public Messenger replyTo;  // 可以发送对此消息的回复。具体如何使用取决于发送者和接收者</span><br><span class="line">    public int sendingUid = -1;</span><br><span class="line"></span><br><span class="line">    /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0;  // 标记消息被使用</span><br><span class="line">    /*package*/ static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1; // 标记消息是异步的</span><br><span class="line">    /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;  </span><br><span class="line">    /*package*/ int flags;</span><br><span class="line">    /*package*/ long when;     // Message 的执行时间 重要！！！</span><br><span class="line">    /*package*/ Bundle data;    </span><br><span class="line">    /*package*/ Handler target;   // target 负责处理该消息</span><br><span class="line">    /*package*/ Runnable callback;  // Runnable 类型的 callback</span><br><span class="line">    /*package*/ Message next;     // 下一条消息，因为消息队列是链式存储的</span><br><span class="line"></span><br><span class="line">    private static final Object sPoolSync = new Object();  // 控制并发访问</span><br><span class="line">    private static Message sPool;   // 回收池的头结点</span><br><span class="line">    private static int sPoolSize = 0;</span><br><span class="line">    private static final int MAX_POOL_SIZE = 50;</span><br><span class="line"></span><br><span class="line">    private static boolean gCheckRecycle = true;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Return a new Message instance from the global pool. Allows us to</span><br><span class="line">     * avoid allocating new objects in many cases.</span><br><span class="line">     */</span><br><span class="line">    public static Message obtain() &#123;</span><br><span class="line">        synchronized (sPoolSync) &#123;</span><br><span class="line">            if (sPool != null) &#123;</span><br><span class="line">                Message m = sPool;  // 将头结点赋值给Message</span><br><span class="line">                sPool = m.next;        // 将头结点更新为下一个节点</span><br><span class="line">                m.next = null;     // 断掉以前头节点与当前节点联系</span><br><span class="line">                m.flags = 0; // clear in-use flag</span><br><span class="line">                sPoolSize--;      // 将回收池的数量减一</span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return new Message();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Message obtain(Handler h) &#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;     // 注意，这里将 Handler 保存在了 target 中，后面会调用target来处理这个Message</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到了最后就是Message 的 obtain() 方法，从 global pool 返回一个新的Message实例。 允许我们在许多情况下避免分配新对象。而这个 global pool 呢，其实就是一个单链表，从头结点取一个 Message ，如果没有就 new 一个 Message。而这个单链表呢，就是讲无用需要回收的 Message 组织起来的。<strong>the global pool 其实就是使用静态常量组织了一些无用了的 Message，组织的数据结构就是单链表。</strong></p>
<p>看源码就知道，重载了多个obtain 方法，其实就是把上述可选参数配置一下，然后调用 obtain() 得到一个Message。</p>
<h3 id="回收-Message"><a href="#回收-Message" class="headerlink" title="回收 Message"></a>回收 Message</h3><p>可能看了生成有点懵，那我们提前看一下回收，就好一点了， Message 的 源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void recycle() &#123;</span><br><span class="line">    if (isInUse()) &#123;           // isInUse() return ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE);</span><br><span class="line">        if (gCheckRecycle) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;</span><br><span class="line">                    + &quot;is still in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;   // 在用就不回收</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();  // 直接回收</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Recycles a Message that may be in-use.</span><br><span class="line"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span><br><span class="line"> */</span><br><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">    // Mark the message as in use while it remains in the recycled object pool.</span><br><span class="line">    // Clear out all other details.</span><br><span class="line">    flags = FLAG_IN_USE;    // 设置为没有使用</span><br><span class="line">    what = 0;             // 抹去数据</span><br><span class="line">    arg1 = 0;</span><br><span class="line">    arg2 = 0;</span><br><span class="line">    obj = null;</span><br><span class="line">    replyTo = null;</span><br><span class="line">    sendingUid = -1;</span><br><span class="line">    when = 0;</span><br><span class="line">    target = null;</span><br><span class="line">    callback = null;</span><br><span class="line">    data = null;</span><br><span class="line"></span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;  // 将当前 Message 的下一个设置为以前的头结点</span><br><span class="line">            sPool = this;   // 更新头结点为当前节点</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125; // 如果到达MAX_POOL_SIZE数量，这个Message就会因为没有与引用链相连而被GC回收</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回收还是很简单的，就是先检验是否在使用，如果不是，抹去上面的数据，将 Message 加到我称为 <code>回收池</code> 的链表里。需要注意的是，这里如果回收池数量到了上限，这个Message就会因为没有与引用链相连而被GC回收。</p>
<h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>MassageQueue 叫做消息队列，通过一个单链表的数据结构来维护消息列表，而且单链表在插入和删除上比较有优势。MessageQueue 主要包含两个操作：插入 和 读取。插入读取对应的方法分别是enqueueMessage(Message msg, long when) 和 next()。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>这里的工作流程先是讲一下例子里面的工作流程，其次补充一些必要的流程，如回收等。</p>
<h3 id="UI线程-Looper-的创建"><a href="#UI线程-Looper-的创建" class="headerlink" title="UI线程 Looper 的创建"></a>UI线程 Looper 的创建</h3><p>我们知道 UI 线程是在 ActivityThread 中创建的，这个函数就是整个 APP 的入口。接下来就是 ActivityThread 中的 main：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ... </span><br><span class="line">    Looper.prepareMainLooper();  // 1. 创建UI线程的 Looper</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        // UI 线程的Handle</span><br><span class="line">        // getHandler() 得到的是 ActivityThread.H (extends Handler)</span><br><span class="line">        sMainThreadHandler = thread.getHandler(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // End of event ActivityThreadMain.</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();    //2. 执行消息循环</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没有，通过1,2步的配置，这时候 UI 线程中 Looper 其实已经跑起来了，在程序中就已经可以使用 Handler 了。而<strong>子线程却默认没有配置</strong>。</p>
<p>需要注意的 UI 线程使用的 <code>prepareMainLooper()</code> 来准备 Looper，但是这个方法虽然是 public 的，但是这是专门为 UI 线程量身定做的，我们绝对不可以使用，我们准备Looper可以使用 Looper 的 <code>prepare()</code>就好。</p>
<h4 id="prepareMainLooper"><a href="#prepareMainLooper" class="headerlink" title="prepareMainLooper()"></a>prepareMainLooper()</h4><p>接下来我们来一步一步分析   (Looper 源码：)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    prepare(false);  // new 一个 Looper 放到该线程的ThreadLocalMap中</span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        if (sMainLooper != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 UI 线程的 Looper 放到静态常量 sMainLooper 中，那么随时随地都可以new 出主线程的 Handler</span><br><span class="line">        sMainLooper = myLooper();  // myLooper() return sThreadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void prepare() &#123;</span><br><span class="line">    prepare(true);  // 子线程中默认是可以销毁消息队列的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;  // True if the message queue can be quit.</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // sThreadLocal 是在类定义的时候就初始化了的 static final ThreadLocal&lt;Looper&gt;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();  // 得到当前线程的 Looper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很简单，结合注释，应该都懂了，<strong>就是 new 了一个 Looper ，放到了主线程的 ThreadLocalMap 中</strong>。那 new 的时候干了什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原来是这样，在 new Looper 的时候就创建了 UI 线程的消息队列，并且指定不可以删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// True if the message queue can be quit.</span><br><span class="line">private final boolean mQuitAllowed;</span><br><span class="line"></span><br><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>队列是否可以删除，一直向下传递，最后原来是保存在这里。但是这里还有一个 Native 方法，是干嘛的呢？笔者认为是得到了这个对象所在线程的引用。</p>
<p>到这里，ActivityThread 中的第一步就算是完成了。由于 sMainThreadHandler 的后期使用涉及复杂，就留到后面讲解，这里用 例子中的 Handler 代替讲解，最后执行的 Handler 是一样的，但是 ActivityThread.H（sMainThreadHandler ）封装了其他东西。</p>
<h4 id="创建-Handler"><a href="#创建-Handler" class="headerlink" title="创建 Handler"></a>创建 Handler</h4><p>看着例子中的 Handler 是直接 new 出来的，那我们看一下 Handler 的无参构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Handler &#123;</span><br><span class="line">    public Handler() &#123;</span><br><span class="line">        this(null, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">       ...</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        if (mLooper == null) &#123;        // ***重要！！！</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到 Handler 在构造方法中，通过 Looper.myLooper() 得到当前线程（UI 线程）的Looper，并且保存到本地 final 变量 mLooper 中。</p>
<p>要知道，<strong>消息队列被封装在 Looper 中，而每一个 Looper 又会关联一个线程（Looper 通过 ThreadLocal 封装），最终等于每一个消息队列都会关联一个线程。</strong>同时，由上代码可知，每个 Handler 也都会关联一个消息队列。在这里需要注意，Looper 和 MessageQueue 并没有与 Handler关联，而是Handler 与 Looper 和 MessageQueue 建立联系。</p>
<h4 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h4><p>创建了Looper之后，就要执行消息循环了，我们知道，通过 Handler 来 Post 消息给消息队列，那么怎么处理呢？那就是最开始第二步的 Looper.loop() 中的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper();  // 获取当前线程的 Looper</span><br><span class="line">    if (me == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final MessageQueue queue = me.mQueue;  // 1. 获取消息队列</span><br><span class="line"></span><br><span class="line">    // Make sure the identity of this thread is that of the local process,</span><br><span class="line">    // and keep track of what that identity token actually is.</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;       // 2. 消息循环</span><br><span class="line">        Message msg = queue.next(); // might block可能阻塞 3. 获取消息</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final long traceTag = me.mTraceTag;</span><br><span class="line">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);  // 4. 处理消息</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (traceTag != 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure that during the course of dispatching the</span><br><span class="line">        // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">        final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked(); // 回收</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到 loop 方法中实际上就是<strong>建立一个死循环，然后通过从消息队列中逐个取出消息，最后进行处理，至到取到 null 值才退出。</strong>这里并没有任何的阻塞，那我消息取完了就退出了么？不，原理请看 MassageQueue 的 next() :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">       final long ptr = mPtr;</span><br><span class="line">       if (ptr == 0) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">       int nextPollTimeoutMillis = 0;</span><br><span class="line">       // 注意，以下的代码都在循环体里面</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">               Binder.flushPendingCommands();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           nativePollOnce(ptr, nextPollTimeoutMillis);  // 重要！！！</span><br><span class="line"></span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               // Try to retrieve the next message.  Return if found.</span><br><span class="line">               final long now = SystemClock.uptimeMillis();   // 从开机到现在的毫秒数（手机睡眠的时间不包括在内）</span><br><span class="line">               Message prevMsg = null;      // 前驱结点</span><br><span class="line">               Message msg = mMessages;  // 头结点</span><br><span class="line"></span><br><span class="line">               // 如果没有 Handler，就在列表中找下一个同步的 Message 来执行。</span><br><span class="line">               if (msg != null &amp;&amp; msg.target == null) &#123;  </span><br><span class="line">                   // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                   do &#123;</span><br><span class="line">                       prevMsg = msg;</span><br><span class="line">                       msg = msg.next;</span><br><span class="line">                   &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (msg != null) &#123;   // 如果头结点不为空</span><br><span class="line">                   if (now &lt; msg.when) &#123;   // 如果还没有到执行时间</span><br><span class="line">                       // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                        // 设置唤醒时间，距离多久执行 与 int 最大值 2^31 - 1 作比较</span><br><span class="line">                       nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       // 注意这时候已经到执行时间了</span><br><span class="line">                       // Got a message.</span><br><span class="line">                       mBlocked = false;</span><br><span class="line">                       // 从消息队列中取出这个 Message</span><br><span class="line">                       if (prevMsg != null) &#123;  // 如果前驱结点不为 null，</span><br><span class="line">                           prevMsg.next = msg.next;   // 请参看 next() 图 1</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           mMessages = msg.next;  //  将头结点后移</span><br><span class="line">                       &#125;</span><br><span class="line">                       msg.next = null;   // 断掉要处理的 Message 与 消息队列的联系</span><br><span class="line">                       if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                       msg.markInUse();   // 标记为使用</span><br><span class="line">                       return msg;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;  // 头结点为空</span><br><span class="line">                   // No more messages.</span><br><span class="line">                   nextPollTimeoutMillis = -1;</span><br><span class="line">               &#125;</span><br><span class="line">               // Process the quit message now that all pending messages have been handled.</span><br><span class="line">               if (mQuitting) &#123;</span><br><span class="line">                   dispose();</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // If first time idle, then get the number of idlers to run.</span><br><span class="line">               // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">               // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">               if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                       &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                   pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">               &#125;</span><br><span class="line">               if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                   // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                   mBlocked = true;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                   mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">           &#125; //同步代码块结束</span><br><span class="line"></span><br><span class="line">           // Run the idle handlers.</span><br><span class="line">           // We only ever reach this code block during the first iteration.</span><br><span class="line">           for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">               final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">               mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">               boolean keep = false;</span><br><span class="line">               try &#123;</span><br><span class="line">                   keep = idler.queueIdle();</span><br><span class="line">               &#125; catch (Throwable t) &#123;</span><br><span class="line">                   Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (!keep) &#123;</span><br><span class="line">                   synchronized (this) &#123;</span><br><span class="line">                       mIdleHandlers.remove(idler);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">           pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">           // While calling an idle handler, a new message could have been delivered</span><br><span class="line">           // so go back and look again for a pending message without waiting.</span><br><span class="line">           nextPollTimeoutMillis = 0;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Disposes of the underlying message queue.</span><br><span class="line">   // Must only be called on the looper thread or the finalizer.</span><br><span class="line">   private void dispose() &#123;</span><br><span class="line">       if (mPtr != 0) &#123;</span><br><span class="line">           nativeDestroy(mPtr);</span><br><span class="line">           mPtr = 0;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码虽然很长，但是我们还是得看啊，其实就是<strong>取出单链表（我们前面已说过，MessageQueue其实是一个单链表结构）中的头结点，然后修改对应指针，再返回取到的头结点</strong>而已。因为这里采用的是无限循环，所以可能会有个疑问：该循环会不会特别消耗CPU资源？其实并不会，如果messageQueue有消息，自然是继续取消息；<strong>如果已经没有消息了，此时该线程便会阻塞在该next()方法的 nativePollOnce() 方法中，主线程便会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生（设置的nextPollTimeoutMillis到了）时，才通过往pipe管道写端写入数据来唤醒主线程工作。</strong>这里涉及到的是Linux的pipe/epoll机制，epoll机制是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3998756-1d77e7ec9bfa20d1.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="next() 图 1"></p>
<p>总结：<br>通过 Looper.loop() 来创建 Looper 对象( 消息队列封装在 Looper 对象中 )，并且保存在 sThreadLocal 中，然后通过 Looper.loop() 来执行消息循环。</p>
<p>说了取，当然接着就是分发了。我们调用msg.target.dispatchMessage(msg) 来执行 Message 。在创建 Message 的过程中，传过来的 Handler 的引用就被保存在了Message中（最上面有代码和讲解）。接下来看一下 Handler 的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">final Callback mCallback;</span><br><span class="line"></span><br><span class="line">public interface Callback &#123;</span><br><span class="line">    public boolean handleMessage(Message msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void handleCallback(Message message) &#123;</span><br><span class="line">    message.callback.run();   // 此时是在 Handler 所在线程中执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面也特别简单，大家都知道当我们在 Handler post()消息的时候是使用 Runnable，而 sendMessage() 是自己构建的 Message。这里首先判断 Message 类型，如果是 Runnable ，就调用run运行，如果不是，先判断创建 Handler 的时候是否设置回调，设置了就调用回调中的处理方法 handleMessage(msg)，如果没有就使用默认的 handleMessage(msg)，这时候的这个方法大多数时候都会被重写，就像例子一样。</p>
<p>这里我们可以看到，在分发消息时三个方法的优先级分别如下：</p>
<ul>
<li>Message的回调方法优先级最高，即message.callback.run()；</li>
<li>Handler的回调方法优先级次之，即Handler.mCallback.handleMessage(msg)；</li>
<li>Handler的默认方法优先级最低，即Handler.handleMessage(msg)。<br><img src="https://upload-images.jianshu.io/upload_images/3998756-7a157510e8b01e00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler 工作原理.png"></li>
</ul>
<h3 id="使用-Handler-来-sendMessage-Message-msg"><a href="#使用-Handler-来-sendMessage-Message-msg" class="headerlink" title="使用 Handler 来 sendMessage(Message msg)"></a>使用 Handler 来 sendMessage(Message msg)</h3><p>既然提到 post() 和 sendMessage()，那么下面就讲解一下它是如何将一个 Message 加到队列中的。</p>
<p>现讲解 sendMessage() 吧，例子就是最上面的例子，那我们接着看 Handler 的源码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Pushes a message onto the end of the message queue after all pending messages</span><br><span class="line"> * before the current time. It will be received in &#123;@link #handleMessage&#125;,</span><br><span class="line"> * in the thread attached to this handler.</span><br><span class="line"> *  </span><br><span class="line"> * @return Returns true if the message was successfully placed in to the </span><br><span class="line"> *         message queue.  Returns false on failure, usually because the</span><br><span class="line"> *         looper processing the message queue is exiting.</span><br><span class="line"> */</span><br><span class="line">public final boolean sendMessage(Message msg)</span><br><span class="line">&#123;</span><br><span class="line">    return sendMessageDelayed(msg, 0);  // 默认延时为 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class="line">&#123;</span><br><span class="line">    if (delayMillis &lt; 0) &#123;  // 校验延时，因为延时只能 &gt;= 0</span><br><span class="line">        delayMillis = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // SystemClock.uptimeMillis() 从开机到现在的毫秒数（手机睡眠的时间不包括在内）</span><br><span class="line">    // SystemClock.uptimeMillis() + delayMillis算出来就是更新时间</span><br><span class="line">    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">    // 这个值是通过从Looper 赋值过来的，就意味着是持有和Looper 中相同的引用</span><br><span class="line">    // Looper 中的修改的话mQueue，这个值也会被修改</span><br><span class="line">    // 当调用 Looper.quit() 的时候，这个值就被置空了的。</span><br><span class="line">    MessageQueue queue = mQueue;  </span><br><span class="line">    if (queue == null) &#123;   // 因为需要发送到 MassageQueue中，所以不能为空</span><br><span class="line">        RuntimeException e = new RuntimeException(</span><br><span class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">        return false;  // 插入失败</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target = this;   // 保存 Message 的 target</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);  </span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一直往下调用了三个方法才到底，还好都简单，来看一下。将设置的时延转化成应该被执行的时间，拿到关联的消息队列，随后保存 Message 的 target，然后调用消息队列的 <code>enqueueMessage(msg, uptimeMillis)</code>，将这个Message 加入队列。那怎么加的么？接下来就是 MessageQueue 的 <code>enqueueMessage(Message msg, long when)</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">    if (msg.target == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (msg.isInUse()) &#123;  // 一个新的 Message 是不会 InUse 的，在回收的时候设置为没在使用的</span><br><span class="line">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;   // 获得自身的同步锁</span><br><span class="line">        if (mQuitting) &#123;  // MessageQueue 正在退出</span><br><span class="line">            IllegalStateException e = new IllegalStateException(</span><br><span class="line">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();  // 将Message实例回收</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();   // flags |= 1 标记正在使用</span><br><span class="line">        msg.when = when;   // 设置要插入 Message 的执行时间</span><br><span class="line">        Message p = mMessages;  // mMessages为头结点</span><br><span class="line">        boolean needWake;      // 线程是否需要唤醒</span><br><span class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">            // New head, wake up the event queue if blocked.</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;   // 线程是否阻塞</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">            // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">            // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();  //记得看上面的英文注释 默认为 false</span><br><span class="line">            Message prev;</span><br><span class="line">            for (;;) &#123;   // 寻找看下图</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                if (p == null || when &lt; p.when) &#123;  </span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;  </span><br><span class="line">                    needWake = false;  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; // invariant: p == prev.next</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">        if (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);  // 唤醒线程的 Native 方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看 enqueueMessage 的实现，它的主要操作就是<strong>单链表的插入操作，并且这链表是以执行时间 when 作为顺序的</strong>。需要重提的是，这时候的 <code>when</code> 已经转换成了距离开机到执行的毫秒数。</p>
<ol>
<li>校验。是检测target是否存在，因为Message. targe 是用来处理这个 Message 的，所以一定要有target，其次判断当前 Message 是否正在被使用，然后验证当前 MessageQueue 是不是已经被 quit 了（mQuitting），验证通过过后就是正式的插入操作。</li>
<li>配置。设置 Message 该有的属性，msg.markInUse();  msg.when = when;</li>
<li><p>这个方法比较巧妙，将几种具体情况用一份代码解决了，但是都可以归结为：<strong>在头结点之前插入结点</strong>。看到这里应该注意到，如果插入的是需要非延时 Message，并且线程阻塞了，就会调用 <code>nativeWake(mPtr)</code> 唤醒线程。</p>
<ul>
<li>当还没有链表的时候（p == 0）</li>
<li>消息的执行时间 比 里面的消息还要早（when == 0 || when &lt; p.when）</li>
</ul>
</li>
<li><p><strong>在链表中间或最后插入</strong>。循环遍历链表，拿到链表合适的 Message，然后再将新 Message 插入。由于还没有到消息的处理时间，就不会唤醒线程。此插入过程如下：<br><img src="https://upload-images.jianshu.io/upload_images/3998756-91258f33b7235a1a.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
</li>
</ol>
<h3 id="使用-Handler-来-post"><a href="#使用-Handler-来-post" class="headerlink" title="使用 Handler 来 post()"></a>使用 Handler 来 post()</h3><p>先上一个使用的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private Handler mHandler;//全局变量</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    mHandler = new Handler();</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);//在子线程有一段耗时操作,比如请求网络</span><br><span class="line">                        mHandler.post(new Runnable() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void run() &#123;</span><br><span class="line">                                mTestTV.setText(&quot;This is post&quot;);//更新UI</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子很简单，就不讲解了，接下来就来看一下 Handler 怎么 post 的吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Causes the Runnable r to be added to the message queue.</span><br><span class="line"> * The runnable will be run on the thread to which this handler is </span><br><span class="line"> * attached. </span><br><span class="line"> *  </span><br><span class="line"> * @param r The Runnable that will be executed.</span><br><span class="line"> * </span><br><span class="line"> * @return Returns true if the Runnable was successfully placed in to the </span><br><span class="line"> *         message queue.  Returns false on failure, usually because the</span><br><span class="line"> *         looper processing the message queue is exiting.</span><br><span class="line"> */</span><br><span class="line">public final boolean post(Runnable r)</span><br><span class="line">&#123;</span><br><span class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">    Message m = Message.obtain();  // 得到一个新的 Message</span><br><span class="line">    m.callback = r;  // 是使用 post 的 Runnable 才会保存有这个参数</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>眼尖的童鞋估计看到就要easy了。在 post 一开始就调用了 <code>sendMessageDelayed(Message msg, long delayMillis)</code>，是不是很眼熟，对的，前面<code>sendMessage(Message msg)</code>一开始也是调用这个方法。这就是非延时消息的插入。后面具体如何插入请参看上一条。</p>
<p>同样的，如果是使用 <code>postDelayed(Runnable r, long delayMillis)</code> 呢？使用<strong>例子请参看 面试题：</strong>Handler机制，Handler除了线程通信还有什么作用 中的作用二的第二种实现方式。转回来看 Handler 的 postDelayed :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final boolean postDelayed(Runnable r, long delayMillis)</span><br><span class="line">&#123;</span><br><span class="line">    return sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原来啊，大家都用的一套，还是调用的 <code>sendMessageDelayed</code> 方法，只不过延迟时延不再为默认的 0. 这时候就是延迟消息的插入。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3998756-7c380a7599210a79.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作原理时间图.jpg"></p>
<h2 id="退出消息循环"><a href="#退出消息循环" class="headerlink" title="退出消息循环"></a>退出消息循环</h2><p>退出消息循环有两种方式，分别是Looper 的 <code>quit()</code> 和 <code>quitSafely()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void quit() &#123;</span><br><span class="line">     mQueue.quit(false);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void quitSafely() &#123;</span><br><span class="line">     mQueue.quit(true);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这还是很简单，直接调用了 MassageQueue 的 <code>qiut(boolean safe)</code> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">    if (!mQuitAllowed) &#123;  // 主线程设置不允许退出，其他子线程默认设置的true</span><br><span class="line">       throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mQuitting) &#123;  // 默认为 false，表示是否正在退出消息队列</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mQuitting = true;  // 全局唯一一次赋值，表示正在退出消息队列</span><br><span class="line"></span><br><span class="line">        if (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We can assume mPtr != 0 because mQuitting was previously false.</span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先判断是否是主线程，因为主线程的消息队列不允许退出，然后判断当前线程是否正在退出。值得注意的是，mQuitting 是 MassageQueue 的成员变量，是拥有默认值的，<strong>默认值是 false</strong>。如果不是正在退出消息队列，则将其标志为 正在退出，注意，<strong>全局就只有这里修改了 mQuitting 的值</strong>。然后判断根据要求是否安全移除 MessageQueue。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private void removeAllMessagesLocked() &#123;</span><br><span class="line">    Message p = mMessages;  // 头结点</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">        Message n = p.next;     // 下一个结点</span><br><span class="line">        p.recycleUnchecked();  // 前面讲过，就是将数据抹去，放入回收的那个链表</span><br><span class="line">        p = n;       </span><br><span class="line">    &#125;</span><br><span class="line">    mMessages = null;   // 将MessageQueue 中保存的头结点设置为 null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void removeAllFutureMessagesLocked() &#123;</span><br><span class="line">    final long now = SystemClock.uptimeMillis();  //  从开机到现在的毫秒数（手机睡眠的时间不包括在内）； </span><br><span class="line">    Message p = mMessages;   // 头结点</span><br><span class="line">    if (p != null) &#123;     </span><br><span class="line">        // 如果头结点设置的延迟时间 &gt; 大于当前时间</span><br><span class="line">        // 注意  这里比较的时候都是用的从开机到现在的毫秒数</span><br><span class="line">        // 这里意味着还没有到设置的执行时间</span><br><span class="line">        if (p.when &gt; now) &#123;    </span><br><span class="line">            removeAllMessagesLocked();  // 直接移除全部还未到执行时间的 Message</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Message n;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                n = p.next;  // 拿到下一个节点</span><br><span class="line">                if (n == null) &#123;  // 结束标志：没有下一个</span><br><span class="line">                    return;   </span><br><span class="line">                &#125;</span><br><span class="line">                if (n.when &gt; now) &#123;  // 还没有到设置的执行时间，退出循环</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line">            // 这时候得到的节点 p 是没有到设置的执行时间的前一个节点</span><br><span class="line">            // n 是没有到设置的执行时间的节点</span><br><span class="line">            p.next = null;</span><br><span class="line">            do &#123;</span><br><span class="line">                p = n;</span><br><span class="line">                n = p.next;</span><br><span class="line">                p.recycleUnchecked();</span><br><span class="line">            &#125; while (n != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>removeAllMessagesLocked()</code>直接将MessageQueue 中的 Message 全部回收掉。无论是延迟消息（延迟消息是指通过sendMessageDelayed或通过postDelayed等方法发送的需要延迟执行的消息）还是非延迟消息（delayMillis == 0）。</p>
<p><code>removeAllFutureMessagesLocked()</code> 方法呢，就是只会清空MessageQueue消息池中所有的延迟消息，并将消息池中所有的非延迟消息派发出去让Handler去处理，在这个方法中，表现为直接return ，然后因为队列有Message，所以相应的 dispatchMessage(msg) 会调用。</p>
<p> quitSafely相比于quit方法安全之处在于清空消息之前会派发所有的非延迟消息。</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h1 id="handler发消息给子线程，looper怎么启动？"><a href="#handler发消息给子线程，looper怎么启动？" class="headerlink" title="handler发消息给子线程，looper怎么启动？"></a>handler发消息给子线程，looper怎么启动？</h1><blockquote>
<p>发消息就是把消息塞进去消息队列，looper在应用起来的时候已经就启动了，一直在轮询取消息队列的消息。</p>
</blockquote>
<p><br></p>
<h2 id="为什么在子线程中创建Handler会抛异常？"><a href="#为什么在子线程中创建Handler会抛异常？" class="headerlink" title="为什么在子线程中创建Handler会抛异常？"></a>为什么在子线程中创建Handler会抛异常？</h2><p>首先看如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Thread()&#123;</span><br><span class="line">    Handler handler = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        handler = new Handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></p>
<p>前面说过，Looper 对象是 ThreadLocal 的，即每个线程都有自己的 Looper，这个 Looper 可以为空。但是，当你在子线程中创建 Handler 对象时，如果 Looper 为空，那就会抛出异常。源码解释一下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Handler &#123;</span><br><span class="line">        ...</span><br><span class="line">    public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        if (mLooper == null) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述程序中，我们可以看到，当 mLooper  对象为空的时候，抛出了异常。这是因为该线程中的 Looper 对象还没有创建，因此 sThreadLocal.get() 会返回 null。Handler 的原理就是要与 MassageQueue 建立关联，并且将消息投递给MassageQueue，如果连 MassageQueue 都没有，那么 Handler 就没有存在的必要，而 MassageQueue 又被封装在 Looper 中，因此，创建 Handler 时 Looper 一定不能为空。解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Thread()&#123;</span><br><span class="line">       Handler handler = null;</span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           Looper.prepare();   // 1. 为当前线程创建 Looper，并会绑定到 ThreadLocal 中</span><br><span class="line">           handler = new Handler();</span><br><span class="line">           Looper.loop();  // 2. 启动消息循环</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;.start();</span><br></pre></td></tr></table></figure></p>
<p>在UI线程为什么可以直接使用呢，就是因为在 ActivityThread中默认帮你执行了 1，2步了的。</p>
<p><br></p>
<h2 id="Handler为什么loop是死循环。"><a href="#Handler为什么loop是死循环。" class="headerlink" title="Handler为什么loop是死循环。"></a>Handler为什么loop是死循环。</h2><p>在android中如果主线程（UI线程）中进行耗时操作会引发ANR（Application Not Responding）异常，产生ANR的原因一般有两种：</p>
<ol>
<li><p>当前的事件没有机会得到处理（即主线程正在处理前一个事件，没有及时的完成或者looper被某种原因阻塞住了）</p>
</li>
<li><p>当前的事件正在处理，但没有及时完成</p>
</li>
</ol>
<p>比如onCreate()中进行了耗时操作，导致点击、触摸等不响应，就会产生ANR。为了避免ANR异常，android使用了Handler消息处理机制，让耗时操作在子线程运行，需要UI线程进行处理的操作给UI线程发送消息。</p>
<p>我们知道Handler发消息给UI线程就可以处理消息，UI线程维护着一个Looper和一个消息队列，Looper不停的拿消息队列的消息去分发处理。到这里问题来了：如果这么做的话，UI线程岂不是要一直死循环轮询消息队列拿消息？死循环不是造成ANR吗？</p>
<p>是的，确实是死循环，但是 ANR 还得另说。</p>
<p>ActivityThread 的 main()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line">    ...</span><br><span class="line">    Looper.loop();</span><br><span class="line"> </span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looper.loop()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    if (me == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line"> </span><br><span class="line">    // Make sure the identity of this thread is that of the local process,</span><br><span class="line">    // and keep track of what that identity token actually is.</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    final long ident = Binder.clearCallingIdentity();</span><br><span class="line"> </span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        ...</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        ...</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Looper.loop()是在死循环处理消息，如果main方法中没有looper进行循环，那么主线程一运行完毕就会退出，那才不正常了呢！？</p>
<p>所以，ActivityThread的main方法主要就是做消息循环，一旦退出消息循环，那么你的应用也就退出了。</p>
<p>那么问题重新问一遍：<strong>那为什么这个死循环不会造成ANR异常呢？</strong></p>
<p>其实原因是显然的，我们知道<strong>Android是由事件驱动的</strong>，Looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞消息。换言之，<strong>消息队列为空的时候会阻塞主线程，而处理消息的时候不可以阻塞，这时候的阻塞 5 s就会 ANR。</strong></p>
<p>也就说我们的代码其实就是在这个循环里面去执行的，当然不会阻塞了。</p>
<p>而且<strong>主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。</strong>因此loop的循环并不会对CPU性能有过多的消耗。</p>
<p>总结：Looer.loop()方法可能会引起主线程的阻塞，但只要它的消息循环没有被阻塞，能一直处理事件就不会产生ANR异常。</p>
<h2 id="Handler-机制-很多细节需要关注：如线程如何建立和退出消息循环等等）"><a href="#Handler-机制-很多细节需要关注：如线程如何建立和退出消息循环等等）" class="headerlink" title="Handler 机制 很多细节需要关注：如线程如何建立和退出消息循环等等）"></a>Handler 机制 很多细节需要关注：如线程如何建立和退出消息循环等等）</h2><p>这里就是让你回答 Handler 的工作原理。</p>
<h2 id="关于Handler，在任何地方new-Handler-都是什么线程下"><a href="#关于Handler，在任何地方new-Handler-都是什么线程下" class="headerlink" title="关于Handler，在任何地方new Handler 都是什么线程下?"></a>关于Handler，在任何地方new Handler 都是什么线程下?</h2><p>这个需要分类讨论：</p>
<ol>
<li><p>像最开始那样呢，直接new 出来，不带Looper 参数，那么就在创建 Looper 的线程下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">    this(null, false);</span><br><span class="line">&#125;</span><br><span class="line">public Handler(Callback callback) &#123;</span><br><span class="line">    this(callback, false);</span><br><span class="line">&#125;</span><br><span class="line">public Handler(boolean async) &#123;</span><br><span class="line">    this(null, async);</span><br><span class="line">&#125;</span><br><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    if (mLooper == null) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在任何地方 new 出指定线程的 Handler。例如主线程，看案例：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">                // 在子线程中实例化Handler同样是可以的，只要在构造函数的参数中传入主线程的Looper即可</span><br><span class="line">                Handler handler = new Handler(Looper.getMainLooper());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>前面讲过，UI线程调用的 prepare 函数不一样，多保存了UI线程的 Looper 到 Looper.sMainLooper 中的。其目的是在任何地方都可以实例化 UI 线程的 Handler。</p>
<p>而这时候调用的构造方法是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Looper looper) &#123;</span><br><span class="line">    this(looper, null, false);</span><br><span class="line">&#125;</span><br><span class="line">public Handler(Looper looper, Callback callback) &#123;</span><br><span class="line">    this(looper, callback, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Handler(Looper looper, Callback callback, boolean async) &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实就是与传入的 Looper绑定，换言之，<strong>如果我传入的是其他线程的Looper，我同样也可以实例化其他线程的 Handler。</strong></p>
<h2 id="请解释下在单线程模型中Message、Handler、Message-Queue、Looper之间的关系"><a href="#请解释下在单线程模型中Message、Handler、Message-Queue、Looper之间的关系" class="headerlink" title="请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系"></a>请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系</h2><p>讲到Handler，肯定离不开Looper、MessageQueue、Message这三者和Handler之间的关系，下面简略地带过，详细自己可以参看上面源码</p>
<ol>
<li><p>Handler<br>将要执行的Message或者Runnable到消息队列。</p>
</li>
<li><p>Looper<br>每一个线程只有一个Looper，每个线程在初始化Looper之后，然后Looper会维护好该线程的消息队列，用来存放Handler发送的Message，并处理消息队列出队的Message。它的特点是它跟它的线程是绑定的，处理消息也是在Looper所在的线程去处理，所以当我们在主线程创建Handler时，它就会跟主线程唯一的Looper绑定，从而我们使用Handler在子线程发消息时，最终也是在主线程处理，达到了异步的效果。</p>
</li>
</ol>
<p>那么就会有人问，为什么我们使用Handler的时候从来都不需要创建Looper呢？这是因为在主线程中，ActivityThread默认会把Looper初始化好，prepare以后，当前线程就会变成一个Looper线程。</p>
<ol start="2">
<li><p>MessageQueue<br>MessageQueue是一个消息队列，用来存放Handler发送的消息。每个线程最多只有一个MessageQueue。MessageQueue通常都是由Looper来管理，而主线程创建时，会创建一个默认的Looper对象，而Looper对象的创建，将自动创建一个MessageQueue。其他非主线程，不会自动创建Looper。</p>
</li>
<li><p>Message<br>消息对象，就是MessageQueue里面存放的对象，一个MessageQueu可以包括多个Message。当我们需要发送一个Message时，我们一般不建议使用new Message()的形式来创建，更推荐使用Message.obtain()来获取Message实例，因为在Message类里面定义了一个消息池，当消息池里存在未使用的消息时，便返回，如果没有未使用的消息，则通过new的方式创建返回，所以使用Message.obtain()的方式来获取实例可以大大减少当有大量Message对象而产生的垃圾回收问题。</p>
</li>
</ol>
<h2 id="Handler机制，Handler除了线程通信还有什么作用"><a href="#Handler机制，Handler除了线程通信还有什么作用" class="headerlink" title="Handler机制，Handler除了线程通信还有什么作用"></a>Handler机制，Handler除了线程通信还有什么作用</h2><p>   Handler的主要用途 :</p>
<ul>
<li>推送未来某个时间点将要执行的Message或者Runnable到消息队列。</li>
<li>在子线程把需要在另一个线程执行的操作加入到消息队列中去。</li>
</ul>
<h4 id="1-推送未来某个时间点将要执行的Message或者Runnable到消息队列"><a href="#1-推送未来某个时间点将要执行的Message或者Runnable到消息队列" class="headerlink" title="1. 推送未来某个时间点将要执行的Message或者Runnable到消息队列"></a>1. 推送未来某个时间点将要执行的Message或者Runnable到消息队列</h4><p>实例：通过Handler配合Message或者Runnable实现倒计时<br><img src="http://upload-images.jianshu.io/upload_images/3998756-3772e7ab118e968f.gif?imageMogr2/auto-orient/strip" alt></p>
<ul>
<li>方法一，通过Handler + Message的方式实现倒计时。代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private ActivityMainBinding mBinding;</span><br><span class="line"></span><br><span class="line">    private Handler mHandler ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        mBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        //设置监听事件</span><br><span class="line">        mBinding.clickBtn.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                //通过Handler + Message的方式实现倒计时</span><br><span class="line">                for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">                    Message message = Message.obtain(mHandler);</span><br><span class="line">                    message.what = 10 - i;</span><br><span class="line">                    mHandler.sendMessageDelayed(message, 1000 * i); //通过延迟发送消息，每隔一秒发送一条消息</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        mHandler = new Handler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                super.handleMessage(msg);</span><br><span class="line">                mBinding.time.setText(msg.what + &quot;&quot;);   //在handleMessage中处理消息队列中的消息</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里用到了DataBiding，可能没用过的同学看起来有点奇怪，但其实反而简略了代码，有一定基础的同学看起来都不会有太大压力。通过这个小程序，笔者希望大家可以了解到Handler的一个作用就是，在主线程中，可以通过Handler来处理一些有顺序的操作，让它们在固定的时间点被执行。</p>
<ul>
<li>方法二，通过Handler + Runnable的方式实现倒计时。代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private ActivityMainBinding mBinding;</span><br><span class="line">    private Handler mHandler = new Handler();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        mBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        //设置监听事件</span><br><span class="line">        mBinding.clickBtn.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">                    final int fadedSecond = i;</span><br><span class="line">                    //每延迟一秒，发送一个Runnable对象</span><br><span class="line">                    mHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            mBinding.time.setText((10 - fadedSecond) + &quot;&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, 1000 * i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>方法二也是通过代码让大家加深Handler处理有序事件的用途，之所以分开Runnable和Message两种方法来实现，是因为很多人都搞不清楚为什么Handler可以推送Runnable和Message两种对象。</p>
<p>其实，<strong>无论Handler将Runnable还是Message加入MessageQueue，最终都只是将Message加入到MessageQueue。</strong>Handler的post Runnable对象这个方法只是对post Message进行了一层封装，即将Runnable 放到的Message 中的 mCallback 存储起来，值得注意的是，如果直接将Message 加入MessageQueue的话，那么mCallback将为null，所以最终我们都是通过Handler推送了一个Message罢了，至于为什么会分开两种方法，只是为了更方便开发者根据不同需要进行调用。下面再来看看Handler的第二个主要用途。</p>
<h4 id="2-在子线程把需要在另一个线程执行的操作加入到消息队列中去"><a href="#2-在子线程把需要在另一个线程执行的操作加入到消息队列中去" class="headerlink" title="2. 在子线程把需要在另一个线程执行的操作加入到消息队列中去"></a>2. 在子线程把需要在另一个线程执行的操作加入到消息队列中去</h4><p>实例：通过Handler + Message来实现子线程加载图片，在UI线程显示图片</p>
<p>效果图如下<br><img src="http://upload-images.jianshu.io/upload_images/3998756-64f0675c2ac4e7f3.gif?imageMogr2/auto-orient/strip" alt><br>代码如下(布局代码也不放出来了)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadActivity extends AppCompatActivity implements View.OnClickListener &#123;</span><br><span class="line">    private ActivityThreadBinding mBinding = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        mBinding = DataBindingUtil.setContentView(this, R.layout.activity_thread);</span><br><span class="line">        // 设置点击事件</span><br><span class="line">        mBinding.clickBtn.setOnClickListener(this);</span><br><span class="line">        mBinding.resetBtn.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        switch (v.getId()) &#123;</span><br><span class="line">            // 响应load按钮</span><br><span class="line">            case R.id.clickBtn:</span><br><span class="line">                // 开启一个线程</span><br><span class="line">                new Thread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        // 在Runnable中进行网络读取操作，返回bitmap</span><br><span class="line">                        final Bitmap bitmap = loadPicFromInternet();</span><br><span class="line">                        // 在子线程中实例化Handler同样是可以的，只要在构造函数的参数中传入主线程的Looper即可</span><br><span class="line">                        Handler handler = new Handler(Looper.getMainLooper());</span><br><span class="line">                        // 通过Handler的post Runnable到UI线程的MessageQueue中去即可</span><br><span class="line">                        handler.post(new Runnable() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void run() &#123;</span><br><span class="line">                                // 在MessageQueue出队该Runnable时进行的操作</span><br><span class="line">                                mBinding.photo.setImageBitmap(bitmap);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">                break;</span><br><span class="line">            case R.id.resetBtn:</span><br><span class="line">                mBinding.photo.setImageBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.default_pic));</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * HttpUrlConnection加载图片，很简单</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Bitmap loadPicFromInternet() &#123;</span><br><span class="line">        Bitmap bitmap = null;</span><br><span class="line">        int respondCode = 0;</span><br><span class="line">        InputStream is = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            URL url = new URL(&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1421494343,3838991329&amp;fm=23&amp;gp=0.jpg&quot;);</span><br><span class="line">            HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            connection.setRequestMethod(&quot;GET&quot;);</span><br><span class="line">            connection.setConnectTimeout(10 * 1000);</span><br><span class="line">            connection.setReadTimeout(5 * 1000);</span><br><span class="line">            connection.connect();</span><br><span class="line">            respondCode = connection.getResponseCode();</span><br><span class="line">            if (respondCode == 200) &#123;</span><br><span class="line">                is = connection.getInputStream();</span><br><span class="line">                bitmap = BitmapFactory.decodeStream(is);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Toast.makeText(getApplicationContext(), &quot;访问失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (is != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很简单，其实最主要的就是当我们需要在主线程执行一些操作的时候，就可以直接使用这种方式，这种方式有着直接发送 Message 不可实现的先天优势。</p>
<h2 id="handler机制组成，handler机制每一部分的源码包括looper中的loop方法、threadlocal概念、dispatchmessage方法源码，runnable封装message等"><a href="#handler机制组成，handler机制每一部分的源码包括looper中的loop方法、threadlocal概念、dispatchmessage方法源码，runnable封装message等" class="headerlink" title="handler机制组成，handler机制每一部分的源码包括looper中的loop方法、threadlocal概念、dispatchmessage方法源码，runnable封装message等"></a>handler机制组成，handler机制每一部分的源码包括looper中的loop方法、threadlocal概念、dispatchmessage方法源码，runnable封装message等</h2><p>上面讲解的还记得住么？</p>
<h2 id="请解释下在单线程模型中Message、Handler、Message-Queue、Looper之间的关系-1"><a href="#请解释下在单线程模型中Message、Handler、Message-Queue、Looper之间的关系-1" class="headerlink" title="请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系"></a>请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系</h2><ol>
<li>Android的单线程模型</li>
</ol>
<p>当一个程序第一次启动时，Android会同时启动一个对应的主线程（Main Thread），主线程主要负责处理与UI相关的事件，如：用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理。所以主线程通常又被叫做UI线程。</p>
<p>在开发Android 应用时必须遵守单线程模型的原则：<strong>Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。</strong></p>
<p>如果在非UI线程中直接操作UI线程，会抛出异常，这与普通的java程序不同。因为 ViewRootImpl 对 UI 操作做了验证，这个验证工作是由 ViewRootImpl 的 checkThread 方法来完成的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void checkThread() &#123;</span><br><span class="line">    if (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        throw new CalledFromWrongThreadException(</span><br><span class="line">                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于UI线程负责事件的监听和绘图，因此，必须保证UI线程能够随时响应用户的需求，UI线程里的操作应该向中断事件那样短小，费时的操作（如网络连接）需要另开线程，否则，如果UI线程超过5s没有响应用户请求，会弹出对话框提醒用户终止应用程序。顺便说一下 ANR 默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。</p>
<p>如果在新开的线程那为什么系统不对 UI 控件的访问<strong>加上锁机制</strong>呢？<strong>缺点</strong>有两个：<strong>首先加上锁机制会让 UI 访问的逻辑变得复杂；其次锁机制会降低 UI 访问的效率，因为锁机制会阻塞某些线程的执行。</strong>鉴于这两个缺点，最简单且高效的方法就是采用<strong>单线程模型</strong>来处理UI操作，对于开发者来说也不是很麻烦，只需要通过 Handler 切换一下 UI 访问的执行线程就好。<br>中需要对UI进行设定，就可能违反单线程模型，因此android采用一种复杂的Message Queue机制保证线程间通信。</p>
<ol start="2">
<li>后面就是分析的那一套了。Message Queue 、 Handler 、 Looper </li>
</ol>
<h2 id="Handler、Thread和HandlerThread的差别"><a href="#Handler、Thread和HandlerThread的差别" class="headerlink" title="Handler、Thread和HandlerThread的差别"></a>Handler、Thread和HandlerThread的差别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">public class HandlerThread extends Thread &#123;</span><br><span class="line">    int mPriority;</span><br><span class="line">    int mTid = -1;</span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    public HandlerThread(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Constructs a HandlerThread.</span><br><span class="line">     * @param name</span><br><span class="line">     * @param priority The priority to run the thread at. The value supplied must be from </span><br><span class="line">     * &#123;@link android.os.Process&#125; and not from java.lang.Thread.</span><br><span class="line">     */</span><br><span class="line">    public HandlerThread(String name, int priority) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Call back method that can be explicitly overridden if needed to execute some</span><br><span class="line">     * setup before Looper loops.</span><br><span class="line">     */</span><br><span class="line">    protected void onLooperPrepared() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * This method returns the Looper associated with this thread. If this thread not been started</span><br><span class="line">     * or for any reason is isAlive() returns false, this method will return null. If this thread </span><br><span class="line">     * has been started, this method will block until the looper has been initialized.  </span><br><span class="line">     * @return The looper.</span><br><span class="line">     */</span><br><span class="line">    public Looper getLooper() &#123;</span><br><span class="line">        if (!isAlive()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // If the thread has been started, wait until the looper has been created.</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            while (isAlive() &amp;&amp; mLooper == null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Quits the handler thread&apos;s looper.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * Causes the handler thread&apos;s looper to terminate without processing any</span><br><span class="line">     * more messages in the message queue.</span><br><span class="line">     * &lt;/p&gt;&lt;p&gt;</span><br><span class="line">     * Any attempt to post messages to the queue after the looper is asked to quit will fail.</span><br><span class="line">     * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false.</span><br><span class="line">     * &lt;/p&gt;&lt;p class=&quot;note&quot;&gt;</span><br><span class="line">     * Using this method may be unsafe because some messages may not be delivered</span><br><span class="line">     * before the looper terminates.  Consider using &#123;@link #quitSafely&#125; instead to ensure</span><br><span class="line">     * that all pending work is completed in an orderly manner.</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return True if the looper looper has been asked to quit or false if the</span><br><span class="line">     * thread had not yet started running.</span><br><span class="line">     *</span><br><span class="line">     * @see #quitSafely</span><br><span class="line">     */</span><br><span class="line">    public boolean quit() &#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        if (looper != null) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Quits the handler thread&apos;s looper safely.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * Causes the handler thread&apos;s looper to terminate as soon as all remaining messages</span><br><span class="line">     * in the message queue that are already due to be delivered have been handled.</span><br><span class="line">     * Pending delayed messages with due times in the future will not be delivered.</span><br><span class="line">     * &lt;/p&gt;&lt;p&gt;</span><br><span class="line">     * Any attempt to post messages to the queue after the looper is asked to quit will fail.</span><br><span class="line">     * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false.</span><br><span class="line">     * &lt;/p&gt;&lt;p&gt;</span><br><span class="line">     * If the thread has not been started or has finished (that is if</span><br><span class="line">     * &#123;@link #getLooper&#125; returns null), then false is returned.</span><br><span class="line">     * Otherwise the looper is asked to quit and true is returned.</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return True if the looper looper has been asked to quit or false if the</span><br><span class="line">     * thread had not yet started running.</span><br><span class="line">     */</span><br><span class="line">    public boolean quitSafely() &#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        if (looper != null) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int getThreadId() &#123;</span><br><span class="line">        return mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 HandlerThread 实在是代码少得变态，我就直接将全部源码贴上来了。</p>
<p>直接看一下run() 方法可能就明白了，就是将 Looper 启动起来，就等于主线程一样，可以直接使用 Handler 了，没必要 Looper.prepare() 再 Looper.loop() 了。<strong>需要知道这根本不是 handler ，而是封装了 Looper 的 Thread</strong>，方便了子线程与子线程通信。</p>
<p>还有一点<br>Handler: 它的消息处理方式是阻塞式的，必须一条一条的处理。耗时操作 不应该用handler处理。</p>
<p>HandlerThread：继承自Thread，它有个Looper，在这里可以执行耗时操作</p>
<h2 id="什么是-IdleHandler？有什么用？怎么用"><a href="#什么是-IdleHandler？有什么用？怎么用" class="headerlink" title="什么是 IdleHandler？有什么用？怎么用"></a>什么是 IdleHandler？有什么用？怎么用</h2><p><a href="https://mp.weixin.qq.com/s/KpeBqIEYeOzt_frANoGuSg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KpeBqIEYeOzt_frANoGuSg</a><br>这里还没写，努力更新中…</p>
<h2 id="Handler消息机制，postDelayed会造成线程阻塞吗？对内存有什么影响？"><a href="#Handler消息机制，postDelayed会造成线程阻塞吗？对内存有什么影响？" class="headerlink" title="Handler消息机制，postDelayed会造成线程阻塞吗？对内存有什么影响？"></a>Handler消息机制，postDelayed会造成线程阻塞吗？对内存有什么影响？</h2><ol>
<li>Handler消息机制</li>
<li>postDelayed会造成线程阻塞吗： </li>
</ol>
<p>还有印象么，上面讲解的 postDelayed。postDelayed只是在 post 的时候加了延时，最后这个延时讲被转换成执行时间存在每一个 Message 中。而在 loop() 中调用 next() 的死循环是阻塞式的，只有在下个消息到达或者有事务发生（设置的nextPollTimeoutMillis到了）时，才通过往pipe管道写端写入数据来唤醒线程工作。</p>
<p>也就是说如果当前消息队列中消息全部为 延时Message（全部没到执行时间），而这个 Message 的执行时间又比MessageQueue 中所有消息执行时间早，那么在loop循环取next 的时候就会因为最早这一个Message（刚刚postDelayed的Message）还没到执行时间而阻塞。</p>
<ol start="3">
<li>对内存有什么影响<br><img src="https://upload-images.jianshu.io/upload_images/3998756-a52c146fe2b91114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ThreadLocal内存解释"><br>Looper 是通过 ThreadLocal 存储在线程中的，而MessageQueue 是封装在 Looper 中的。</li>
</ol>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a href="https://developer.android.com/reference/android/os/Handler" target="_blank" rel="noopener">Android 官方文档 ：Handler </a><br><a href="https://developer.android.com/reference/android/os/MessageQueue" target="_blank" rel="noopener">MessageQueue</a><br><a href="https://developer.android.com/reference/android/os/Looper#myQueue(" target="_blank" rel="noopener">Looper</a>)<br>《 Android 开发艺术探索 》<br>《 Android 开发进阶  从小工到专家 》<br><a href="https://blog.csdn.net/reakingf/article/details/52054598" target="_blank" rel="noopener">深入理解Android中的Handler机制</a><br><a href="https://www.jianshu.com/p/b03d46809c4d" target="_blank" rel="noopener">一步一步分析Android的Handler机制</a><br><a href="https://blog.csdn.net/ashqal/article/details/32107099" target="_blank" rel="noopener">【从源码看Android】03Android MessageQueue消息循环处理机制（epoll实现）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/26/Android的消息机制-Handler/" data-id="ck1ghe1f5000w08vz56lfw7zk"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Framework/">Framework</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2018/11/15/View的事件分发拦截机制/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            View 的事件分发拦截机制
          
        </div>
      </a>
    
    
      <a href="/2018/07/24/ThreadLocal原理/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">ThreadLocal 原理</div>
      </a>
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: '7fe0aa956b684f67dc71',
      clientSecret: '6d1c739bf59040f4fa8b09bf4bebcfa7ed9d1cea',
      repo: 'rhine-li-lei.github.io',
      owner: 'rhine-li-lei',
      admin: ['rhine-li-lei'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 rhine(黎磊)</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

<aside class="sidebar sidebar-specter">
  
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/ProfilePicture.jpg" alt="rhine(黎磊)"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>