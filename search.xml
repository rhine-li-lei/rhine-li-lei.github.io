<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[View的绘制流程]]></title>
    <url>%2F2019%2F10%2F07%2FView%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[View 的绘制流程是 Android 开发的必备知识点之一 API：26 View 树因为这不是重点，所以介绍得比较简单，下次写文章详细讲解View树的形成与关系。 一个 Activity 会形成一棵以 ViewRoot 为根节点的 View 树。ViewRoot 的实现类就是 ViewGroupImlp，这棵树形成流程为： Activity onCreate setContentView() 的时候解析后形成以 DecorView 为根节点的 View 树 Activity 启动的最后在 WindowManagerGlobal 生成 ViewRootImpl 并将之与DecorView绑定在一起 那问题来了，ViewRoot 不是 View 啊，怎么形成的树呢，实际上 ViewRootImpl 和 ViewGroup 都实现了 ViewParent 接口，View 有一个 mParent 字段存储父节点。 过程简介View的绘制流程的起点是 DecorView 的 performTraversals() 方法开始的，顺着 View 树进行分发，而每一个View 经过 measure、layout、draw 后就被展示出来，其中，measure 是测量View的宽高，layout是确定在父View 中的位置，draw是将View绘制在屏幕上。 从流程图上可知： ViewRootImpl 的 performTraversals() 依次调用ViewRootImpl的 performMeasure() 、performLayout()、performDraw() 方法。 performMeasure() 又会调用子View的 measure()，measuer() 会调用自己的onMeasure() ，这时候onMeasure()又会对子View进行 measure 同理，performLayout()、performDraw() 也是这样完成。 这就实现了 自顶向下 的测量、放置、绘制流程，而且要清楚 整个View树测量完成才开始放置，放置结束才开始绘制。 MeasureSpec在进行代码讲解之前，还需要了解 MeasureSpec。 MeasureSpec 是一个32位的 int 值。 SpecMode：测量模式，父View指定 SpecSize：测量大小，具体某个测量模式下View的大小 MeasureSpec 传递流程：父 View会将自己的MeasureSpec传递下来，子 View 会根据父 View 的 MeasureSpec 和 View 本身的 LayoutParams 来确定自己的 MeasureSpec，从而进一步决定 View 的宽和高。 测量模式有三类：EXACTLY, UNSPECIFIED, AT_MOST。分别代表精确大小，不精确大小，最大值。 EXACTLY：父 View 不对 View 有任何限制，一般用于系统内部。 UNSPECIFIED：父View已知子View的大小，这个时候子View的最终大小就是MeasureSpec所指定的值，对应LayoutParams中的match_parent 和具体数值两种模式。 AT_MOST：父View指定可用大小（SpecSize），子 View 的大小不能大于这个值，对应LayoutParams中的warp_content。 有人说 MeasureSpec 是为了节约内存才这么做的，我觉得吧，系统也不缺一个int值，最主要是把 SpecMode、SpecSize 绑定在一起，一来可以不用在逻辑上保证两者的对应，减少代码复杂度，二来方便操作与传递。 performTraversals()ViewRootImpl 是 ViewRoot的实现类，他的 performTraversals() 方法是 View 绘制流程的起点。 12345678910111213141516171819202122232425262728293031323334private void performTraversals() &#123; // cache mView since it is used so much below... final View host = mView; // decorView // 省略若干... if (!mStopped || mReportNextDraw) &#123; boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) &#123; int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); // lp.width：MATCH_PARENT or WRAP_CONTENT, or an exact size int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); // 就是window的大小 // 省略若干... performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // 测量 // 省略若干... if (measureAgain) &#123; performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // 递归的进测量 &#125; &#125; &#125; &#125; // 省略若干... if (didLayout) &#123; performLayout(lp, mWidth, mHeight); // 递归的进摆放 // 省略若干... &#125; &#125; // 省略... performDraw(); // 递归的进行绘制 &#125; // 省略...&#125; 删减了部分代码后，我们能很清晰的看到 performTraversals() 依次调用了 ViewRootImpl 的 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); performLayout(lp, mWidth, mHeight); performDraw(); 进行测量、摆放、绘制的分发。 说明（个人理解）：为什么要叫 childWidthMeasureSpec 呢？为什么不是widthMeasureSpec 呢？是因为这个值作用于子 View，对父 View 没啥用，但是是在父View中计算出来的。 measureViewRootImplperformTraversals() 通过 getRootMeasureSpec() 方法得到对应宽高的MeasureSpec， 然后将得到的宽高的 MeasureSpec 传递给 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec) 进行分发。 其中，传给 performMeasure 的 MeasureSpec 的大小就是window的大小，测量模式由Window的LayoutParams决定。代码如下： 1234567891011121314151617private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // 指定了 Window 的大小，就以指定的为准 measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; 这个 MeasureSpec 是 ViewRootImpl 要传递给 DecorView 的，用于决定 DecorView 的大小。由此可知，DecorView默认情况下就是屏幕的大小。 那传给 performMeasure 怎么处理的呢？1234567891011private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; if (mView == null) &#123; return; &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 这里面比较简单，直接就分发给 mView了。 mView 是ViewRootImpl的成员变量，通过addView添加进来，就是DecorView。 相当于performMeasure() 直接交给了 View 的 measure()。 View直接交给了View，那 View#Measure() 源码走起12345678910111213141516public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 省略... final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; // 省略... final boolean needsLayout = specChanged &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); if (forceLayout || needsLayout) &#123; // 强制刷新或者需要测量的时候才会进行测量 // 省略... if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; onMeasure(widthMeasureSpec, heightMeasureSpec); // 测量 mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; // 省略... &#125; // 省略...&#125; 比较简单，无关的剔除了。代码很简单主要就是做记录、是否需要测量、调用onMeasure() 测量。 值得注意的是 measure() 方法是 final 的，所以ViewGroup 不可能覆写，我们也不能覆盖，所以我们如果要修改测量的逻辑，就只能在 onMeasure() 中重写。 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 默认实现比较简单粗暴，setMeasuredDimension 方法就是设置 View 宽高的测量值，调用 setMeasuredDimension 记录下来的值默认情况下就是View最后的大小。测量结束后一定要记得调用 setMeasuredDimension 方法保存测量值。 那 getDefaultSize 方法怎么实现的呢？12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: // 父 View 不对 View 有任何限制，一般用于系统内部 result = size; break; case MeasureSpec.AT_MOST: // 对应 warp_content case MeasureSpec.EXACTLY: // match_parent、具体数值 result = specSize; break; &#125; return result;&#125; 对于AT_MOST、EXACTLY 两种测量模式下，就是直接返回 MeasureSpec 的测量大小。所以也是为什么自定义 View 的时候要自己重写 onMeasure 方法并设置 wrap_content 时候的 View 大小，因为默认情况下 wrap_content == match_parent 。同时我们也可以知道，正常app开发情况下，getSuggestedMinimumHeight()、getSuggestedMinimumWidth() 得到的值没用，我们选择忽略他。 所以，到这里基本知道了，如果分发给一个 View，如果没有重写 onMeasure 方法的话，他的父View传给他的 MeasureSpec 就可以决定他的测量结果。 那么问题来了，ViewRootImpl 分发给 DecorView 进行绘制，DecorView 是一个 ViewGroup，那他怎么实现ViewGroup 的测量呢？ viewGroupViewGroup 子类的布局特点会影响测量过程，ViewGroup 没有重写 onMeasure 方法，所以默认情况下，不测量子View，同时把自己当做一个View进行测量，比如 LinearLayout、RelativeLayout 等 ViewGroup 都需要重写 onMeasure 方法才能测量子 View并且特征化决定自己多大。 以 LinearLayout 垂直布局 wrap_content 为例，在决定自己有多大之前，会对每一个子View调用measure方法，并将初步高度累加存储在mTotalLength，而最终高度是 mTotalLength 与父View剩余高度取最小。 所以不同的 ViewGroup 子类决定了测量方式的不同，具体测量细节都被各种各样的 ViewGroup 所接管，与此同时，很多 ViewGroup 的子类会进行多次测量，这也是不同 ViewGroup 性能不同的原因之一。 但是，ViewGroup 提供了一些辅助方法帮助我们测量子 View ，而自己在默认情况下就是一个View的测量方式：ViewGroup 的父 View 说多大就多大。 12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125; 很简单，就是循环测量 Visibility 不为 GONE 的子 View，我们需要知道的是传入谁的 MeasureSpec 进来呢，需要传入的是当前 View 的 MeasureSpec。 那子View具体怎么测量的呢？ 1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); // lp.width：MATCH_PARENT or WRAP_CONTENT, or an exact size final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 获取到子View的 MeasureSpec 然后传递给子View 的 measure 方法，那是怎么得到子 View 的 MeasureSpec 呢？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); // 去除padding后父容器的剩余空间 int resultSize = 0; // 最终结果 int resultMode = 0; switch (specMode) &#123; // 父 View 的测量模式 case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 上面方法主要是根据父View的 MeasureSpec 和子 View 的属性来最终决定 View 的大小，可以总结为以下规则： childLayoutParams/parentSpecMode EXACTLY AT_MOST UNSPECIFIED dp、px EXACTLYchildSize EXACTLY childSize EXACTLY childSize match_parent EXACTLYparentSize AT_MOSTparentSize UNSPECIFIED0 wrap_content AT_MOSTparentSize AT_MOSTparentSize UNSPECIFIED0 测量总结 测量由 ViewRootImpl 的 performMeasure 方法分发下来。 决定子 View 的 MeasureSpec 是在父 View 中产生，由父 View 的测量模式、剩余空间和子 View 的 LayoutParams 共同决定。 顶层View DecorView 的 默认大小就是窗口的大小 ViewGroup 默认不测量子 View，测量细节自己决定，有可能需要测量多次，但是提供测量子View的辅助方法。 layoutLayout 过程相对于 measure 过程相对要简单一些，这个过程主要是确定元素的位置，layout 方法是 View 本身的位置，而onLayout 方法是确定子 View 的位置，这也是自定义ViewGroup 的时候必须要实现 onLayout 方法的原因。 ViewRootImpl1234567891011121314151617181920212223private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; // DecorView if (host == null) &#123; return; &#125; try &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); // 重点 mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) &#123; // 当View树在Layout过程的时候调用了 requestLayout() 就会进入这个分支 // 省略... &#125; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; mInLayout = false;&#125; 代码结构很清晰，直接分发给了 DecorView 的 layout 方法。同时传递过去的大小就是测量后的结果。 ViewGroup、ViewViewGroup 重写了 View 的 layout 方法，我们先看下 ViewGroup 的 layout 方法。123456789101112@Overridepublic final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop&apos;d it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125;&#125; ViewGroup 重写的 layout 方法，实现很简单，就是在过渡的时候先不调用 layout 方法，结束再调用。正常情况下，还得看 View 的 layout 方法实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); // setFrame 设置四个顶点位置 if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) &#123; if(mRoundScrollbarRenderer == null) &#123; mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); &#125; &#125; else &#123; mRoundScrollbarRenderer = null; &#125; mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; if ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) &#123; mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT; notifyEnterOrExitForAutoFillIfNeeded(true); &#125;&#125; View layout 方法主要就是调用了 setFrame(l, t, r, b) 方法设置 View 四个顶点的位置，确定了在父容器中的位置。然后调用 onLayout 方法确定子 View 的位置。 对于 View 来说，不需要确定子View的位置，所以默认是空实现：12protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; 而对于 ViewGroup 来说，onLayout 跟 onMeasure 方法有异曲同工之妙，两个都跟具体的布局有关，所以ViewGroup 整了一个abstract 方法，自定义 ViewGroup 必须实现：123@Overrideprotected abstract void onLayout(boolean changed, int l, int t, int r, int b); 简单举下 LinearLayout 垂直布局的 onLayout 方法，其实就是遍历子 View ，并且在父 View 范围内，挨着挨着向下放置，放置过程很简单，距离顶部高度一直累加计算，最后计算出位置后，调用子 View 的 layout 方法。 drawdraw 过程具体实现已经控制比较复杂，但是我们可以知道 performDraw 方法向下分发，传递给 View 的 draw 方法中，draw 方法会调用 onDraw 方法进行绘制自己，那怎么向下分发？这里面是用 dispatchDraw 方法进行分发，而 draw 具体做了什么？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas&apos; layers to prepare for fading * 3. Draw view&apos;s content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); // 绘制背景 &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // 绘制自己 // Step 4, draw the children dispatchDraw(canvas); // 绘制子View drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // 绘制装饰(前景，滚动条) // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); if (debugDraw()) &#123; debugDrawFocus(canvas); &#125; // we&apos;re done... return; &#125; // 省略... // 正常不走这里&#125; 注释很清楚，主要是四大步（通常情况下另两步跳过）： 绘制背景 绘制自己 （onDraw 方法，也是自定义重写的原因） 绘制子 View 绘制装饰（前景，滚动条）]]></content>
      <categories>
        <category>Android系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系列学习]]></title>
    <url>%2F2019%2F10%2F03%2FAndroid%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[版权声明： 本站所有博文内容均为原创，转载请务必注明作者与原文链接，且不得篡改原文内容。 Android 系统 从这张图里面我们能清楚知道每一层的作用，本博客主要在 Framework 和 Native、Android Runtime 两层作讲解。 FrameworkFramework 通过使用Java语言编写的API，您可以使用Android OS的整个功能集。 这些API通过简化核心，模块化系统组件和服务的重用，构成了创建Android应用所需的构建块，其中包括： 丰富而可扩展的View System Resource Manager Notification Manager Activity Manager Content Providers Native C/C++ Libraries许多核心的Android系统组件和服务（例如ART和HAL）都是根据需要使用C和C ++编写的本机库的本机代码构建的。 Android平台提供了Java框架API，以将某些本机库的功能公开给应用程序。 如果您要开发需要C或C ++代码的应用程序，则可以使用Android NDK直接从您的本机代码访问其中一些本机平台库。 Android Runtime对于运行Android 5.0版（API级别21）或更高版本的设备，每个应用程序都以自己的进程运行，并带有自己的Android运行时（ART）实例。 通过执行DEX文件（一种专门为Android设计的字节码格式，已针对最小的内存占用空间进行了优化），ART可以在低内存设备上运行多个虚拟机。 构建工具链（例如Jack）将Java源代码编译为DEX字节码，该代码可在Android平台上运行。 对于这一部分讲解主要会停留在虚拟机概念上。 目标这是一篇立flag的文章，自己想在这两层做源码分析，这将是整个文章的目录。 通信方式Android 是基于 Linux 开发，进程间、线程间的通信必不可少，其中进程间的通信方式主要有 文件 AIDL（基于binder） Binder Messenger（基于binder） ContentProvider（基于binder） socket而线程间进程通信呢，主要就是Handler，整个Android的消息机制都是建立在Handler上的。 Android 进程Android 系统启动过程就是由Boot loader引导开机，以此进入 内核， Native，Framework，App 系统稳定性系统稳定性主要分为超时(timeout)和异常崩溃(crash)。 系统组件对于Android来说，最为著名的就是四大组件，Activity、Service、Broadcast Receiver、ContentProvider；这四大部分的源码对于Android工程师来说应该是最为手到擒来的了。 系统服务AMS、PMS 、WMS等系统服务作为我们最为熟知的系统服务他是怎么工作的，了解一下？ 虚拟机如何在 Android 平台上跑Java 代码呢？虚拟机扮演着十分重要的角色，5.0之前是 Dalvik虚拟机，之后是Android Runtime(ART)虚拟机，原理了解下？]]></content>
      <categories>
        <category>Android系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的事件分发拦截机制]]></title>
    <url>%2F2018%2F11%2F15%2FView%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%8B%A6%E6%88%AA%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[这一个知识点也是写烂了的，可是作为 Android 开发者又不得不学习这部分，学习了呢，总觉得要写点东西出来才觉得有感觉，得，就有这一篇文章了。 API 27 流程介绍在单点触摸中，我们对屏幕的点击，滑动，抬起等一系的动作都是由一个一个MotionEvent对象组成的触摸事件。MotionEvent 是对一个对一个事件的封装，里面包括动作、坐标等等信息，根据不同动作，主要有以下三种事件类型： ACTION_DOWN：手指刚接触屏幕，按下去的那一瞬间产生该事件 ACTION_MOVE：手指在屏幕上移动时候产生该事件 ACTION_UP：手指从屏幕上松开的瞬间产生该事件 要要注意触摸事件不是独立的，而是成组的，每一组事件都是由按下事件开始的，由抬起事件或者取消事件结束。我们把由 ACTION_DOWN 开始（按下），ACTION_UP （抬起）或者 ACTION_CANCEL（取消） 结束的一组事件称为事件序列或者说事件流。取消事件是一种特殊的事件，它对应的是事件序列非人为的提前结束。 举个例子：点击事件：ACTION_DOWN -&gt; ACTION_UP滑动事件：ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_MOVE -&gt; ACTION_UP Android 每产生一个 TouchEvent 事件，他会先问最表面是否消费，如果不消费就交给他的ViewGroup，一层一层向上传递，最终被消费掉（消费就是以为着事件被处理了，代码体现为返回值，true为消费，false为不消费，消费后不再传递）。TouchEvent 不断产生，事件就会不断分发，处理，实现对事件对应的操作进行判断和反馈处理。 还是举个栗子：一个button被点击一下，就会产生两个 TouchEvent 事件，当第一个 TouchEvent 产生，button 发现自己被按下，背景风格变成按下状态，如水波纹、颜色变深等。当第二个Up 的 TouchEvent 产生、分发的时候，button判别自己被点击，背景风格恢复默认状态，并且如果设置了ClickListener的话，调用 OnClick 方法。 那么如果你的ViewGroup里面不止一个View呢（不是废话吗），不止一个ViewGroup呢？那是不是我就要制定一个机制来决定谁来处理这个事件啊？安排 当事件刚触摸到屏幕的时候，即 ACTION_DOWN 这个 MotionEvent 产生的时候，如果ViewGroup中的View消费（返回true），就将这个View记录下来。后续这一个事件流都直接交给它处理。 其实只有 ACTION_DOWN 事件需要返回 true，其后的像 UP啊，Move啊，他们的返回值并没有什么影响，但是还是推荐都写成true，降低维护成本。 当情况复杂，比如说你现在操作的是列表，点一下会触发点击事件，滑一下就会滑动，那么这样的隔着一个View如何实现的呢？这就是依靠着的就是事件拦截机制。 我们将这个过程细分，当你触摸的时候（DOWN事件），这个事件其实是先传到Activity、再传到ViewGroup、最终再传到 View，先问问ViewGroup你拦不拦截啊？一层一层的向下问，如果拦截呢，就直接交给他，如果不拦截呢？就直接往下传，直到传到底层的View，底层的View没有拦截方法，直接问他消不消费，不消费，向上分发，问他的ViewGroup是否分发，如果消费就直接交给它消费掉。这样的话，就可以把消费的权力先交给子View，在合适的时候父View可以马上接管过来。 那么滑动的过程呢？就是在DOWN事件发生的时候，先交给子View消费，当出现MOVE事件的时候，列表发现这个是滑动，需要自己处理，就拦截并且消费掉。但是这时候View还等着后续的事件流，就比如说背景风格还是按下状态，那么父View就会发给它一个cancel事件，让他恢复状态，并且后续事件交给拦截的父View来处理。 始于 Activity点击事件产生最先传递到当前的Activity，由Acivity的dispatchTouchEvent方法来对事件进行分发。12345678910111213141516171819/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 代码很简单，我们来一行一行进行解析。最开始，就是就是判断当前这个事件是否是按下这个事件( MotionEvent.ACTION_DOWN)，如果是，就执行一个空方法( onUserInteraction() 等待程序猿大爷重写) 123456789101112131415161718192021/** * Called whenever a key, touch, or trackball event is dispatched to the * activity. Implement this method if you wish to know that the user has * interacted with the device in some way while your activity is running. * This callback and &#123;@link #onUserLeaveHint&#125; are intended to help * activities manage status bar notifications intelligently; specifically, * for helping activities determine the proper time to cancel a notfication. * * &lt;p&gt;All calls to your activity&apos;s &#123;@link #onUserLeaveHint&#125; callback will * be accompanied by calls to &#123;@link #onUserInteraction&#125;. This * ensures that your activity will be told of relevant user activity such * as pulling down the notification pane and touching an item there. * * &lt;p&gt;Note that this callback will be invoked for the touch down action * that begins a touch gesture, but may not be invoked for the touch-moved * and touch-up actions that follow. * * @see #onUserLeaveHint() */public void onUserInteraction() &#123;&#125; 这里多说几句，这个空方法是在哪些时候会调用呢？毕竟我们也是要重写的嘛，那就必须知道其执行的时期：activity在分发各种事件的时候会调用该方法，旨在提供帮助Activity智能地管理状态栏通知。当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法。下拉statubar、旋转屏幕、锁屏不会触发此方法。所以它会用在屏保应用上，因为当你触屏机器，就会立马触发一个事件，而这个事件又不太明确是什么，正好屏保满足此需求；或者对于一个Activity，控制多长时间没有用户点响应的时候，自己消失等。 我们接着往下看getWindow().superDispatchTouchEvent(ev)：123public Window getWindow() &#123; return mWindow;&#125; 直接返回当前界面的 mWindow，mWindow 是什么啊，是 Window ，Window 我们都知道，是一个 抽象类，它的唯一实现类就是 PhoneWindow，那我们来点一下 superDispatchTouchEvent(MotionEvent)1234567/** * Used by custom windows, such as Dialog, to pass the touch screen event * further down the view hierarchy. Application developers should * not need to implement or call this. * */public abstract boolean superDispatchTouchEvent(MotionEvent event); Window 的抽象方法啊，那我们在 PhoneWindow找一找1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 哇，实现要不要就这么简单，直接由Window 直接传递给了 mDecor，mDecor是什么啊？是 DecorView。123public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123;&#125; DecorView就是Window的顶级View，是一个ViewGroup，我们通过setContentView设置的View是它的子View（Activity的setContentView，最终是调用PhoneWindow的setContentView). 这里放一张 Activity-&gt;视图 的图片 是不是简单几步就实现了由Activity到ViewGroup的传递，这个中间传递者呢，就是Window。 上面传递到了 DecorView，他直接调用了 ViewGroup 的dispatchTouchEvent()进行分发了。123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);&#125; 在陷入复杂的分发逻辑之前，我们先看 Acivity#dispatchTouchEvent留下的一个尾巴 – 最后这个return onTouchEvent(ev);123456789101112131415161718/** * Called when a touch screen event was not handled by any of the views * under it. This is most useful to process touch events that happen * outside of your window bounds, where there is no view to receive it. * * @param event The touch screen event being processed. * * @return Return true if you have consumed the event, false if you haven&apos;t. * The default implementation always returns false. */public boolean onTouchEvent(MotionEvent event) &#123; if (mWindow.shouldCloseOnTouch(this, event)) &#123; // 当超出边界要关闭Window，且超出边界，且顶层的 DecorView 不为空 finish(); return true; &#125; return false; // 默认情况&#125; Activity#onTouchEvent 是我们经常重写的方法，执行了 onTouchEvent表示 getWindow().superDispatchTouchEvent(ev)返回的是 false，我们都知道在事件分发体系中，true 表示消费了这个事件（处理了这个事件），那么onTouchEvent 被调用表示这个事件没有任何View消费，只能交给 Activity 处理，如何处理？就是调用 onTouchEvent 这个方法。 来看一下Window#shouldCloseOnTouch12345678910/** @hide */public boolean shouldCloseOnTouch(Context context, MotionEvent event) &#123; final boolean isOutside = event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; isOutOfBounds(context, event) || event.getAction() == MotionEvent.ACTION_OUTSIDE; if (mCloseOnTouchOutside &amp;&amp; peekDecorView() != null &amp;&amp; isOutside) &#123; return true; &#125; return false;&#125; 这里判断mCloseOnTouchOutside标记及是否为ACTION_DOWN事件，同时判断event的x、y坐标是不是超出Bounds，然后检查FrameLayout的content的id的DecorView是否为空，进行简单判断，由此决定是否销毁这个 Activity。 到这里 Activity 这一层就分析完了。我们在这里理一下： 先判断是否是按下事件，是则 调用onUserInteraction();空方法 在 if 括号中分发，首先是交给Activity上的 Window，Window交给顶级视图 DecorView，DecorView 调用父类 ViewGroup#dispatchTouchEvent 进行分发。 如果在分发结束后，没人消费这个事件，就调用Activity#onTouchEvent 进行处理，处理得很简单，就是判断是否需要超出边界就销毁当前的Activity，需要且超出边界就finish 并且返回true，默认为false。 ViewGroup书接上文，当我们将事件交给 ViewGroup#dispatchTouchEvent ，那他怎么处理的呢？ 真的可以说是超级长了，墙裂推荐使用编辑器看。还有就是看注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218 @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 检查合法性代码省略 boolean handled = false; // 是否消费 if (onFilterTouchEventForSecurity(ev)) &#123; // 以安全策略判断是否可以分发，true-&gt;可以分发 final int action = ev.getAction(); // 事件动作 不同的位存储有不同的信息 final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // 事件类型 // 注释1 // Handle an initial down. 处理第一次按下 if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); // 将当前事件分发下去，并且将整个TouchTarget链表回收 resetTouchState(); // 重置Touch状态标识 &#125; // Check for interception. 标记ViewGroup是否拦截Touch事件的传递 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; // 当事件是按下或者已经找到能够接收touch事件的目标组件 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; // 是否禁止拦截 注释2 if (!disallowIntercept) &#123; // 如果自己可以拦截，默认可以 intercepted = onInterceptTouchEvent(ev); // 注释3 默认不拦截，用于重写 ev.setAction(action); // restore action in case it was changed &#125; else &#123; // 不可以拦截，直接将intercepted 设置为false intercepted = false; &#125; &#125; else &#123; // 注意，重点，当不是事件序列开始，而且还没有设置分发的子View，那么只有一种可能，就是在这之前就被我自己拦截过了，后续序列我默认拦截消费 // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. // 不是事件流开始的 ACTION_DOWN，也没有事件流的消费组件，那么直接拦截。 intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. 检查 cancel 事件 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // 开始事件分发 // Update list of touch targets for pointer down, if needed. // 是否把事件分发给多个子View，设置： ViewGroup#setMotionEventSplittingEnabled final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; // 用于存储已经是事件流承受者的TargetView（在mFirstTouchTarget 这个事件流消费者链表中） boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; // 不取消，不拦截，就分发 // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; // 处理ACTION_DOWN事件 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down // 当前 MotionEvent 的动作标识 final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; // 子View数量 if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; // 有子View可分发 final float x = ev.getX(actionIndex); // 得到点击的X坐标 final float y = ev.getY(actionIndex); // 得到y坐标 // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); // 子View的集合 注释4（顺序问题） final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; // 也是所有子View for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; // 倒序访问 final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); // 得到下标，正常情况下就是 i final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // 取出 i 对用的View // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) // 注意，这就是主要的筛选条件：1. 能不能接收事件（不可见或者在动画） || !isTransformedTouchPointInView(x, y, child, null)) &#123; // 2. 是不是在他的范围内 ev.setTargetAccessibilityFocus(false); continue; &#125; // 注释5 如果在 mFirstTouchTarget中，就返回当前这个封装了child 的 TouchTarget，没有就返回null（注意，这时候这个View已经是在） newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // 在mFirstTouchTarget 这个事件流消费者链表中，找到事件流的消费者，跳出循环 // Child is already receiving touch within its bounds. newTouchTarget.pointerIdBits |= idBitsToAssign; break; // 像UP、MOVE等事件就是从这里跳出循环的 &#125; resetCancelNextUpFlag(child); // 重置flag：cancel next up if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // 注释6 重中之重 就是这里分发，看子View是否消费 // Child wants to receive touch within its bounds. 如果消费了 mLastTouchDownTime = ev.getDownTime(); // 更新按下事件 if (preorderedList != null) &#123; // childIndex points into presorted list, find original index // 找到在ViewGroup 中存储的child，最原始的下标 for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; // 找到ViewGroup 中的数组的原始下标，保存在ViewGroup的成员变量中 break; &#125; &#125; &#125; else &#123; // 临时的排过序的数组为null mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); // 被消费的事件流的DOWN事件的触摸点X（起点x坐标） mLastTouchDownY = ev.getY(); // 起点y坐标 newTouchTarget = addTouchTarget(child, idBitsToAssign); // 将消费事件流的子View的父View（当前ViewGroup）记录在消费的链表头 插入操作可见注释7 alreadyDispatchedToNewTouchTarget = true; // 表示已经成功分发给自己的子View break; &#125; // The accessibility focus didn&apos;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; // for循环结束 if (preorderedList != null) preorderedList.clear(); &#125; // 处理是 if (newTouchTarget == null &amp;&amp; childrenCount != 0)，意味着子View不为0并且没有记录的情况下的处理 // dispatchTransformedTouchEvent方法返回false，意味着子View也不消费 if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event.没有child接收事件 // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; // DOWN 事件的处理结束 &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // 子View不消费 // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); // 交给自己处理（源码下面有） &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; // 头节点 while (target != null) &#123; final TouchTarget next = target.next; // 后驱节点 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; // 这两个值是在第一次dispatchTransformedTouchEvent的时候返回true赋值的，意味着事件被子View消费 handled = true; // 如果被消费了 &#125; else &#123; // 不分发给子View，意味着被拦截或者子View与父ViewGroup临时视图分离（mPrivateFlags设置了PFLAG_CANCEL_NEXT_UP_EVENT），就向记录在的 // 是否分发给子View final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; // 当前ViewGroup是否拦截 if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; // 如果不分发分发子View，调用dispatchTransformedTouchEvent发送cancel事件，已经分发过了就排除新的触摸目标 handled = true; // 是否自己或者子View消费 &#125; if (cancelChild) &#123; // 事件不分发给子View，有可能是被拦截了 if (predecessor == null) &#123; // 具体链表操作看 注释8 mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 注释1：这里呢，就是当一个 ACTION_DOWN 事件来了以后，需要清除一些以前事件序列的标记，开始下一个事件序列。在 cancelAndClearTouchTargets(ev) 方法中有一个非常重要的操作就是将mFirstTouchTarget设置为了null，在resetTouchState()方法中重置Touch状态标识。 mFirstTouchTarget 是 TouchTarget，ViewGroup 的成员变量，记录要消费整个事件流的View，一个触摸事件可能有多个View可以接收到,该参数把他们连接成链状。 注释2这里介绍一下几个基础知识，让大家知道为什么有这个事件拦截。 当我们按下的时候，即 ACTION_DOWN 发生的时候，标志着整个事件流的开始，这时候我们会去找整个事件流的处理者，对应的就是整个事件分发流程，一旦找到这个事件流的处理者（消费了这个事件的ACTION_DOWN），那么后续的整个事件流都会直接发送给这个处理者进行消费掉。 就比如说屏幕上有一个button，我滑动一下按钮，则从 ACTION_DOWN 的时候找到消费这个事件的组件了，然后button表现出按下状态。而后续整个 ACTION_MOVE 事件和 ACTION_UP 事件都直接发送给这个button处理。当下一个事件流来到又重复上述过程。 当情况变复杂的时候，比如说是列表，首先一来就是一个 ACTION_DOWN 事件，可是我也不知道他是点击还是按下啊，所以只能分发下去，交给了item消费了，可是我发现他是滑动事件，那么我就要从子View 中把消费事件的权利抢过来，就是拦截了。而item呢？还是一个按下状态，就发送一个 ACTION_CANCEL 事件给他让他恢复状态。这里呢，意思就是说，当一个事件流我交给子View消费过后，后续不再分发给我，但是在整个事件流处理过程中，我可以随时拦截，交给我来处理。 而假如我是子View，我又不希望我的ViewGroup拦截怎么办呢？当然有办法：ViewGroup#requestDisallowInterceptTouchEvent12345678910111213141516171819public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123; // We&apos;re already in this state, assume our ancestors are too // 已经处于这种状态 return; &#125; if (disallowIntercept) &#123; mGroupFlags |= FLAG_DISALLOW_INTERCEPT; &#125; else &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; // Pass it up to our parent if (mParent != null) &#123; mParent.requestDisallowInterceptTouchEvent(disallowIntercept); &#125;&#125; 很简单，设置 ViewGroup的标志位，并递归告诉父ViewGroup不要拦截。 注释3123456789public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (ev.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123; return true; &#125; return false;&#125; 在当前ViewGroup可以拦截的情况下，看自己拦不拦截呢？不拦截，鼠标那个事件就不考虑了，看到没有，默认返回false，不拦截。当然这个方法主要也是用于我们重写。 注释4preorderedList中的顺序：按照addView或者XML布局文件中的顺序来的，后addView添加的子View，会添加在列表的后面，会因为Android的UI后刷新机制显示在上层； 在事件分发的时候倒序遍历分发，那么最上层的View就可以最先接收到这个事件流，并决定是否消费这个事件流。 注释5123456789101112/** * Gets the touch target for specified child view. * Returns null if not found. */private TouchTarget getTouchTarget(@NonNull View child) &#123; for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) &#123; if (target.child == child) &#123; return target; &#125; &#125; return null;&#125; 从这里我们可以很清楚的明白，首先存储消费事件的目标组件的数据结构是链表，其次 mFirstTouchTarget 就是头节点。而 getTouchTarget 就是遍历整个链表，如果有就返回这个TouchTarget，没有就返回null，最后返回的值存储在 newTouchTarget 中。 这里我们介绍一下 TouchTarget ，TouchTarget 作为 ViewGroup 的内部类，原理很像Message的原理。Android 的消息机制 介绍传送门12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* Describes a touched view and the ids of the pointers that it has captured. * * This code assumes that pointer ids are always in the range 0..31 such that * it can use a bitfield to track which pointer ids are present. * As it happens, the lower layers of the input dispatch pipeline also use the * same trick so the assumption should be safe here... */private static final class TouchTarget &#123; private static final int MAX_RECYCLED = 32; // 回收池最大容量 private static final Object sRecycleLock = new Object[0]; // 回收时候同步控制需要持有的对象锁 private static TouchTarget sRecycleBin; // 回收池的头节点，注意是 static private static int sRecycledCount; // 当前回收池的数量 public static final int ALL_POINTER_IDS = -1; // all ones // The touched child view. public View child; //存储的数据：View。整个事件流的消费者 // The combined bit mask of pointer ids for all pointers captured by the target. public int pointerIdBits; // The next target in the target list. public TouchTarget next; //下一个节点 private TouchTarget() &#123; // 不能在外部new出来 &#125; // 将传入的数据封装成一个TouchTarget链表的结点 public static TouchTarget obtain(@NonNull View child, int pointerIdBits) &#123; if (child == null) &#123; // 需要传入封装的对象吖 throw new IllegalArgumentException(&quot;child must be non-null&quot;); &#125; final TouchTarget target; // 最后构建出来存储的链表节点 synchronized (sRecycleLock) &#123; // 拿到同步锁 if (sRecycleBin == null) &#123; target = new TouchTarget(); // 回收池为空，直接内部new出来 &#125; else &#123; target = sRecycleBin; // 将头节点作为目标节点 sRecycleBin = target.next; // 将头节点下移一个 sRecycledCount--; // 回收池数量减一 target.next = null; // 将取出的节点与链表的联系断掉 &#125; &#125; target.child = child; // 装进节点 target.pointerIdBits = pointerIdBits; return target; &#125; // 提供回收当前节点的方法 public void recycle() &#123; if (child == null) &#123; throw new IllegalStateException(&quot;already recycled once&quot;); &#125; synchronized (sRecycleLock) &#123; // 拿到同步锁 if (sRecycledCount &lt; MAX_RECYCLED) &#123; // 没有超过回收池容量 next = sRecycleBin; // 当前回收节点指向回收池链表的头结点 sRecycleBin = this; // 回收池头结点指向自己，相当于上移 sRecycledCount += 1; // 数量加1 &#125; else &#123; next = null; // 置空，help Gc &#125; child = null; // 抹除记录的数据 &#125; &#125;&#125; 既然最后是一条以为头结点的链表，那么他到底存的是哪些View呢？上一张图： 当我们按下 button2 的时候，会一层一层的传下去，最下层的消费了，然后返回上层接着执行代码（方法调用的时候是当前方法就被压入栈中，调用方法执行结束再弹出执行），上层会在 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign))的时候得到true，将刚刚消费的子View（ViewGroup/View）记录进链表。 注释6下面就是在第一次什么都没有的时候进行分发，注意哦，这里还在循环里面，就意味着这次循环没找到记录，并且触摸点在这个ViewGroup范围内，可见，那我就分发。 接下来详细看一下ViewGroup#dispatchTransformedTouchEvent12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // 是否消费 // Canceling motions is a special case. We don&apos;t need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); // 获取当前事件 if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; // 取消，或者是取消事件 event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; // 传进来的子View为空 handled = super.dispatchTouchEvent(event); // 当前ViewGroup 来执行，调用的是父类View的方法 &#125; else &#123; handled = child.dispatchTouchEvent(event); // 直接交给传进来的子View，在这里就是循环的时候倒序获取的View &#125; event.setAction(oldAction); // 设置为 ACTION_CANCEL return handled; &#125; // Calculate the number of pointers to deliver.计算要传递的指针数。 final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) &#123; // 异常情况，放弃处理 return false; &#125; // If the number of pointers is the same and we don&apos;t need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; // Perform any necessary transformations and dispatch. if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); // 回收TouchTarget return handled;&#125; 这里引用大神的分析： 在dispatchTouchEvent()中多次调用了dispatchTransformedTouchEvent()方法，而且有时候第三个参数为null，有时又不是，他们到底有啥区别呢？这段源码中很明显展示了结果。在dispatchTransformedTouchEvent()源码中可以发现多次对于child是否为null的判断，并且均做出如下类似的操作。其中，当child == null时会将Touch事件传递给该ViewGroup自身的dispatchTouchEvent()处理，即super.dispatchTouchEvent(event)（也就是View的这个方法，因为ViewGroup的父类是View）；当child != null时会调用该子view(当然该view可能是一个View也可能是一个ViewGroup)的dispatchTouchEvent(event)处理，即child.dispatchTouchEvent(event)。别的代码几乎没啥需要具体注意分析的。 具体的什么时候会传空呢，我们接着往下看，后面会分析和总结。 注释712345678910/** * Adds a touch target for specified child to the beginning of the list. * Assumes the target child is not already present. */private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); // 获取节点，并将数据装进去 target.next = mFirstTouchTarget; // 将新节点的next指向下一个节点 mFirstTouchTarget = target; // 头结点记录为当前节点 return target; // 返回头节点&#125; 到这里，整个 ViewGroup 层就结束啦，这里来总结下，dispatchTransformedTouchEvent()什么时候会传入一个null的child呢？ ViewGroup 没有子View 子元素处理了点击事件，但是在 dispatchTouchEvent 中返回了false，这一般都是因为子 View 在onTouchEvent 中返回了 false。 注释8这里主要分析的是循环中的链表操作12345678910111213141516171819202122232425while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next;&#125; View 最后可能接收到进行消费我们知道前面按着正常情况下，就是调用View的dispatchTouchEvent方法，将事件传递给子View，接下来就是View的show time。 View#dispatchTouchEvent12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * 传递给目标View 或者 查看它是否是目标 * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // 可访问焦点优先处理 // We don&apos;t have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; // 是否被处理、消费 if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // 当按下事件发生 // Defensive cleanup for new gesture stopNestedScroll(); // 停止嵌套滚动 &#125; if (onFilterTouchEventForSecurity(event)) &#123; // 根据参数确定是否可以分发：这是一种安全策略（正常情况况下为true） if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; // 作为滚动条拖动就直接处理滚动事件，并直接消费，返回true result = true; // 滚动条的时候 &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; // 各种listener定义在一起的静态内部类，包括我们熟悉的 onClickListener if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED // 验证 li 中的 mOnTouchListener 不为空，可以调用 &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; // 调用onTouch 方法 result = true; // onTouch返回true就消费 &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; // onTouch 不消费就交给onTouchEvent，消费就变true result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 看着注释基本都可以看懂，但是这里又一个东西得看一下，方便对一些事件的理解，那就是 onTouchEvent 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/** * Implement this method to handle touch screen motion events. * &lt;p&gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * &#123;@link #performClick()&#125;. This will ensure consistent system behavior, * including: * &lt;ul&gt; * &lt;li&gt;obeying click sound preferences * &lt;li&gt;dispatching OnClickListener calls * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when * accessibility features are enabled * &lt;/ul&gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); // 获取点击坐标 final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); // 获取Action类型 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; // 是否是可点击状态 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn&apos;t respond to them. return clickable; &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: // 抬起的时候 mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; handleTooltipUp(); // 处理弹窗类型的抬起事件 &#125; if (!clickable) &#123; // 如果不可点击，移除相关接口设置和设置不可点击，并跳出选择 removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; &#125; boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don&apos;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. // 标志着被按下，背景风格转化为按下状态 setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state 如果我们处于按下状态，则仅执行点击操作 if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; // post到主线程执行这个Runnable，这Runnable是由View实现，内部调用li.mOnClickListener.onClick(this); performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: // 按下状态 if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123; mPrivateFlags3 |= PFLAG3_FINGER_DOWN; &#125; mHasPerformedLongPress = false; if (!clickable) &#123; // 不是点击的话，有可能就是长按 checkForLongClick(0, x, y); break; &#125; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we&apos;re inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away 视图不是在滚动中，就把自己变为按下状态 setPressed(true, x, y); // 按下状态，为点击事件做准备 checkForLongClick(0, x, y); // 为长按做准备 &#125; break; case MotionEvent.ACTION_CANCEL: // 恢复默认状态 if (clickable) &#123; setPressed(false); // 恢复默认背景风格 &#125; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) &#123; drawableHotspotChanged(x, y); &#125; // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button // Remove any future long press/tap checks removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; &#125; break; &#125; return true; &#125; return false;&#125; 所有的流程最后都可以归结到这张图上 整个事件传递就这样结束了，在这个过程中，拦截分发的代码交错在一起，我这里总结一下流程： 事件分发开始于Activity#dispatchTouchEvent，先交给getWindow().superDispatchTouchEvent(ev)，返回false再交给Activity#onTouchEvent(ev) 在 PhoneWindow()#superDispatchTouchEvent(ev) 中，直接交给了顶层View：DecorView#superDispatchTouchEvent 在 DecorView#superDispatchTouchEvent 直接 super.dispatchTouchEvent(event)，意味着调用父类ViewGroup#dispatchTouchEvent 处理。 调用 ViewGroup#onInterceptTouchEvent 判断是否拦截 如果拦截，就super. 如果不拦截并且是事件流的开始的话（DOWN 事件），就调用ViewGroup#dispatchTransformedTouchEven 分发下去 如果分发成功，就将分发成功的View存在 mFirstTouchTarget 链表中 如果遍历分发，没人消费，或没有子View的话，就调用父类（也是View啊）的 dispatchTouchEvent，这里面就会执行onTouch / onTouchEvent 方法]]></content>
      <categories>
        <category>Android系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的消息机制-Handler]]></title>
    <url>%2F2018%2F07%2F26%2FAndroid%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler%2F</url>
    <content type="text"><![CDATA[为了更好的理解 Looper 的工作原理，我们需要对 ThreadLocal 进行了解，如果对 ThreadLocal 没有了解的童鞋，可以参看 ThreadLocal 原理 概述 一句话原理：共享内存 Handler 作为日常开发的必备，不可避免就要涉及这方面的知识。从开发者角度来说，Handler 是 Android 消息机制的上层接口，使得开发的时只需与 Handler 交互即可。Handler 使用也很简单，能够轻松将一个任务切换到 Handler 所在的线程中执行。 很多人认为Handler的作用就是更新UI，的确没错，但是更新UI仅仅是Handler的一个特殊的使用场景。具体来说，就是有时候需要在子线程做一些耗时操作，比如说访问网络或者耗时的I/O操作，当这些耗时操作完成时，程序的UI进行相应的改变。由于安卓开发规范的限制，我们不能在子线程中访问UI控件，因为UI的控件是线程非安全的，这个时候通过Handler就可以将更新UI的操作切换到主线程中执行。Android 的消息机制主要是指 Handler 的运行机制。事实上，Handler，Looper，MessageQueue 是一套运行体制而出现的，MessageQueue 是一个消息队列，以队列形式提供插入和删除，主要用于消息的存储，内部实现是采用单链表的形式来组织 Message。而 Looper 用于处理消息，Looper 内部会以无限循环去查是否有新的 Message ，有则处理，没有就等待。需要特殊说明的是，Looper 内部是使用 ThreadLocal 实现的，由于ThreadLocal 可以在每一个线程中互不干扰的存取数据，所以通过ThreadLocal 就可以轻松获取每个线程的 Looper。 Message ：android.os.Message是定义一个Messge包含必要的描述和属性数据，并且此对象可以被发送给android.os.Handler处理。属性字段：arg1、arg2、what、obj、replyTo等；其中arg1和arg2是用来存放整型数据的；what是用来保存消息标示的；obj是Object类型的任意对象；replyTo是消息管理器，会关联到一个handler，handler就是处理其中的消息。通常对Message对象不是直接new出来的，只要调用handler中的obtainMessage方法来直接获得Message对象。 需要特殊说明的是，线程是默认没有 Looper 的，如果需要使用 Handler 就必须为线程创建Looper，但是APP 的主线程中，即 ActivityThread ，在主线程被创建的时候就会初始化 Looper。另外，在没有Looper 的线程创建 Handler 也会失败。 使用案例话不多说，上例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends AppCompatActivity &#123; private TextView textView; private String TAG = &quot;MainActivity&quot;; private int i = 0; Handler mHandler = new Handler()&#123; /** * handleMessage接收消息后进行相应的处理 * @param msg */ @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); if(msg.what==1)&#123; textView.setText(msg.arg1+&quot;&quot;); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView) findViewById(R.id.textView); &#125; public void onClick(View v)&#123; ++i; //创建新的线程 new Thread()&#123; @Override public void run() &#123; super.run(); doSendMsg(); &#125; &#125;.start(); &#125; /** * 在子线程中做耗时操作，完成之后，通知Handler更新UI */ private void doSendMsg()&#123; try &#123; Thread.sleep(1000);//模拟耗时操作 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Message message = Message.obtain(); message.arg1 = i; message.what = 1; mHandler.sendMessage(message); &#125;&#125; 原理分析代码版本 ： Android API25 Message生成一个 Message前面讲过 Message 通常不是 new 出来的，而是通过调用 Handler 的obtainMessage() 得到一个新的 Message：1234public final Message obtainMessage() &#123; return Message.obtain(this); &#125; 而 Handler 就调用 Message 的 obtain(Handler h) 方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public final class Message implements Parcelable &#123; public int what; // 让接收者知道这是什么 public int arg1; // 存储 int 用于传递过去 public int arg2; public Object obj; // 传递一个对象过去 public Messenger replyTo; // 可以发送对此消息的回复。具体如何使用取决于发送者和接收者 public int sendingUid = -1; /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0; // 标记消息被使用 /*package*/ static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1; // 标记消息是异步的 /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE; /*package*/ int flags; /*package*/ long when; // Message 的执行时间 重要！！！ /*package*/ Bundle data; /*package*/ Handler target; // target 负责处理该消息 /*package*/ Runnable callback; // Runnable 类型的 callback /*package*/ Message next; // 下一条消息，因为消息队列是链式存储的 private static final Object sPoolSync = new Object(); // 控制并发访问 private static Message sPool; // 回收池的头结点 private static int sPoolSize = 0; private static final int MAX_POOL_SIZE = 50; private static boolean gCheckRecycle = true; /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; // 将头结点赋值给Message sPool = m.next; // 将头结点更新为下一个节点 m.next = null; // 断掉以前头节点与当前节点联系 m.flags = 0; // clear in-use flag sPoolSize--; // 将回收池的数量减一 return m; &#125; &#125; return new Message(); &#125; public static Message obtain(Handler h) &#123; Message m = obtain(); m.target = h; // 注意，这里将 Handler 保存在了 target 中，后面会调用target来处理这个Message return m; &#125;// ...&#125; 到了最后就是Message 的 obtain() 方法，从 global pool 返回一个新的Message实例。 允许我们在许多情况下避免分配新对象。而这个 global pool 呢，其实就是一个单链表，从头结点取一个 Message ，如果没有就 new 一个 Message。而这个单链表呢，就是讲无用需要回收的 Message 组织起来的。the global pool 其实就是使用静态常量组织了一些无用了的 Message，组织的数据结构就是单链表。 看源码就知道，重载了多个obtain 方法，其实就是把上述可选参数配置一下，然后调用 obtain() 得到一个Message。 回收 Message可能看了生成有点懵，那我们提前看一下回收，就好一点了， Message 的 源码：1234567891011121314151617181920212223242526272829303132333435363738public void recycle() &#123; if (isInUse()) &#123; // isInUse() return ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE); if (gCheckRecycle) &#123; throw new IllegalStateException(&quot;This message cannot be recycled because it &quot; + &quot;is still in use.&quot;); &#125; return; // 在用就不回收 &#125; recycleUnchecked(); // 直接回收&#125;/** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; // 设置为没有使用 what = 0; // 抹去数据 arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; // 将当前 Message 的下一个设置为以前的头结点 sPool = this; // 更新头结点为当前节点 sPoolSize++; &#125; // 如果到达MAX_POOL_SIZE数量，这个Message就会因为没有与引用链相连而被GC回收 &#125;&#125; 回收还是很简单的，就是先检验是否在使用，如果不是，抹去上面的数据，将 Message 加到我称为 回收池 的链表里。需要注意的是，这里如果回收池数量到了上限，这个Message就会因为没有与引用链相连而被GC回收。 MessageQueueMassageQueue 叫做消息队列，通过一个单链表的数据结构来维护消息列表，而且单链表在插入和删除上比较有优势。MessageQueue 主要包含两个操作：插入 和 读取。插入读取对应的方法分别是enqueueMessage(Message msg, long when) 和 next()。 工作流程这里的工作流程先是讲一下例子里面的工作流程，其次补充一些必要的流程，如回收等。 UI线程 Looper 的创建我们知道 UI 线程是在 ActivityThread 中创建的，这个函数就是整个 APP 的入口。接下来就是 ActivityThread 中的 main： 12345678910111213141516171819public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); // 1. 创建UI线程的 Looper ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; // UI 线程的Handle // getHandler() 得到的是 ActivityThread.H (extends Handler) sMainThreadHandler = thread.getHandler(); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); //2. 执行消息循环 throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 看到没有，通过1,2步的配置，这时候 UI 线程中 Looper 其实已经跑起来了，在程序中就已经可以使用 Handler 了。而子线程却默认没有配置。 需要注意的 UI 线程使用的 prepareMainLooper() 来准备 Looper，但是这个方法虽然是 public 的，但是这是专门为 UI 线程量身定做的，我们绝对不可以使用，我们准备Looper可以使用 Looper 的 prepare()就好。 prepareMainLooper()接下来我们来一步一步分析 (Looper 源码：)1234567891011121314151617181920212223242526public static void prepareMainLooper() &#123; prepare(false); // new 一个 Looper 放到该线程的ThreadLocalMap中 synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; // 将 UI 线程的 Looper 放到静态常量 sMainLooper 中，那么随时随地都可以new 出主线程的 Handler sMainLooper = myLooper(); // myLooper() return sThreadLocal.get(); &#125;&#125;public static void prepare() &#123; prepare(true); // 子线程中默认是可以销毁消息队列的&#125;private static void prepare(boolean quitAllowed) &#123; // True if the message queue can be quit. if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; // sThreadLocal 是在类定义的时候就初始化了的 static final ThreadLocal&lt;Looper&gt; sThreadLocal.set(new Looper(quitAllowed));&#125;public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); // 得到当前线程的 Looper&#125; 很简单，结合注释，应该都懂了，就是 new 了一个 Looper ，放到了主线程的 ThreadLocalMap 中。那 new 的时候干了什么呢？1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 原来是这样，在 new Looper 的时候就创建了 UI 线程的消息队列，并且指定不可以删除。1234567// True if the message queue can be quit.private final boolean mQuitAllowed;MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; 队列是否可以删除，一直向下传递，最后原来是保存在这里。但是这里还有一个 Native 方法，是干嘛的呢？笔者认为是得到了这个对象所在线程的引用。 到这里，ActivityThread 中的第一步就算是完成了。由于 sMainThreadHandler 的后期使用涉及复杂，就留到后面讲解，这里用 例子中的 Handler 代替讲解，最后执行的 Handler 是一样的，但是 ActivityThread.H（sMainThreadHandler ）封装了其他东西。 创建 Handler看着例子中的 Handler 是直接 new 出来的，那我们看一下 Handler 的无参构造方法：1234567891011121314151617public class Handler &#123; public Handler() &#123; this(null, false); &#125; public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; // ***重要！！！ throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125;&#125; 我们看到 Handler 在构造方法中，通过 Looper.myLooper() 得到当前线程（UI 线程）的Looper，并且保存到本地 final 变量 mLooper 中。 要知道，消息队列被封装在 Looper 中，而每一个 Looper 又会关联一个线程（Looper 通过 ThreadLocal 封装），最终等于每一个消息队列都会关联一个线程。同时，由上代码可知，每个 Handler 也都会关联一个消息队列。在这里需要注意，Looper 和 MessageQueue 并没有与 Handler关联，而是Handler 与 Looper 和 MessageQueue 建立联系。 Looper.loop()创建了Looper之后，就要执行消息循环了，我们知道，通过 Handler 来 Post 消息给消息队列，那么怎么处理呢？那就是最开始第二步的 Looper.loop() 中的。1234567891011121314151617181920212223242526272829303132333435363738public static void loop() &#123; final Looper me = myLooper(); // 获取当前线程的 Looper if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // 1. 获取消息队列 // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; // 2. 消息循环 Message msg = queue.next(); // might block可能阻塞 3. 获取消息 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); // 4. 处理消息 &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); msg.recycleUnchecked(); // 回收 &#125;&#125; 我们可以看到 loop 方法中实际上就是建立一个死循环，然后通过从消息队列中逐个取出消息，最后进行处理，至到取到 null 值才退出。这里并没有任何的阻塞，那我消息取完了就退出了么？不，原理请看 MassageQueue 的 next() :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; // 注意，以下的代码都在循环体里面 for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); // 重要！！！ synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); // 从开机到现在的毫秒数（手机睡眠的时间不包括在内） Message prevMsg = null; // 前驱结点 Message msg = mMessages; // 头结点 // 如果没有 Handler，就在列表中找下一个同步的 Message 来执行。 if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; // 如果头结点不为空 if (now &lt; msg.when) &#123; // 如果还没有到执行时间 // Next message is not ready. Set a timeout to wake up when it is ready. // 设置唤醒时间，距离多久执行 与 int 最大值 2^31 - 1 作比较 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 注意这时候已经到执行时间了 // Got a message. mBlocked = false; // 从消息队列中取出这个 Message if (prevMsg != null) &#123; // 如果前驱结点不为 null， prevMsg.next = msg.next; // 请参看 next() 图 1 &#125; else &#123; mMessages = msg.next; // 将头结点后移 &#125; msg.next = null; // 断掉要处理的 Message 与 消息队列的联系 if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); // 标记为使用 return msg; &#125; &#125; else &#123; // 头结点为空 // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; //同步代码块结束 // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; // Disposes of the underlying message queue. // Must only be called on the looper thread or the finalizer. private void dispose() &#123; if (mPtr != 0) &#123; nativeDestroy(mPtr); mPtr = 0; &#125; &#125; 代码虽然很长，但是我们还是得看啊，其实就是取出单链表（我们前面已说过，MessageQueue其实是一个单链表结构）中的头结点，然后修改对应指针，再返回取到的头结点而已。因为这里采用的是无限循环，所以可能会有个疑问：该循环会不会特别消耗CPU资源？其实并不会，如果messageQueue有消息，自然是继续取消息；如果已经没有消息了，此时该线程便会阻塞在该next()方法的 nativePollOnce() 方法中，主线程便会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生（设置的nextPollTimeoutMillis到了）时，才通过往pipe管道写端写入数据来唤醒主线程工作。这里涉及到的是Linux的pipe/epoll机制，epoll机制是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 总结：通过 Looper.loop() 来创建 Looper 对象( 消息队列封装在 Looper 对象中 )，并且保存在 sThreadLocal 中，然后通过 Looper.loop() 来执行消息循环。 说了取，当然接着就是分发了。我们调用msg.target.dispatchMessage(msg) 来执行 Message 。在创建 Message 的过程中，传过来的 Handler 的引用就被保存在了Message中（最上面有代码和讲解）。接下来看一下 Handler 的处理： 12345678910111213141516171819202122232425final Callback mCallback;public interface Callback &#123; public boolean handleMessage(Message msg);&#125;public void handleMessage(Message msg) &#123;&#125;public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125;private static void handleCallback(Message message) &#123; message.callback.run(); // 此时是在 Handler 所在线程中执行&#125; 这里面也特别简单，大家都知道当我们在 Handler post()消息的时候是使用 Runnable，而 sendMessage() 是自己构建的 Message。这里首先判断 Message 类型，如果是 Runnable ，就调用run运行，如果不是，先判断创建 Handler 的时候是否设置回调，设置了就调用回调中的处理方法 handleMessage(msg)，如果没有就使用默认的 handleMessage(msg)，这时候的这个方法大多数时候都会被重写，就像例子一样。 这里我们可以看到，在分发消息时三个方法的优先级分别如下： Message的回调方法优先级最高，即message.callback.run()； Handler的回调方法优先级次之，即Handler.mCallback.handleMessage(msg)； Handler的默认方法优先级最低，即Handler.handleMessage(msg)。 使用 Handler 来 sendMessage(Message msg)既然提到 post() 和 sendMessage()，那么下面就讲解一下它是如何将一个 Message 加到队列中的。 现讲解 sendMessage() 吧，例子就是最上面的例子，那我们接着看 Handler 的源码吧：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Pushes a message onto the end of the message queue after all pending messages * before the current time. It will be received in &#123;@link #handleMessage&#125;, * in the thread attached to this handler. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. */public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0); // 默认延时为 0&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; // 校验延时，因为延时只能 &gt;= 0 delayMillis = 0; &#125; // SystemClock.uptimeMillis() 从开机到现在的毫秒数（手机睡眠的时间不包括在内） // SystemClock.uptimeMillis() + delayMillis算出来就是更新时间 return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; // 这个值是通过从Looper 赋值过来的，就意味着是持有和Looper 中相同的引用 // Looper 中的修改的话mQueue，这个值也会被修改 // 当调用 Looper.quit() 的时候，这个值就被置空了的。 MessageQueue queue = mQueue; if (queue == null) &#123; // 因为需要发送到 MassageQueue中，所以不能为空 RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; // 插入失败 &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; // 保存 Message 的 target if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 一直往下调用了三个方法才到底，还好都简单，来看一下。将设置的时延转化成应该被执行的时间，拿到关联的消息队列，随后保存 Message 的 target，然后调用消息队列的 enqueueMessage(msg, uptimeMillis)，将这个Message 加入队列。那怎么加的么？接下来就是 MessageQueue 的 enqueueMessage(Message msg, long when) ：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; // 一个新的 Message 是不会 InUse 的，在回收的时候设置为没在使用的 throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; // 获得自身的同步锁 if (mQuitting) &#123; // MessageQueue 正在退出 IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); // 将Message实例回收 return false; &#125; msg.markInUse(); // flags |= 1 标记正在使用 msg.when = when; // 设置要插入 Message 的执行时间 Message p = mMessages; // mMessages为头结点 boolean needWake; // 线程是否需要唤醒 if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; // 线程是否阻塞 &#125; else &#123; // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); //记得看上面的英文注释 默认为 false Message prev; for (;;) &#123; // 寻找看下图 prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); // 唤醒线程的 Native 方法 &#125; &#125; return true;&#125; 看 enqueueMessage 的实现，它的主要操作就是单链表的插入操作，并且这链表是以执行时间 when 作为顺序的。需要重提的是，这时候的 when 已经转换成了距离开机到执行的毫秒数。 校验。是检测target是否存在，因为Message. targe 是用来处理这个 Message 的，所以一定要有target，其次判断当前 Message 是否正在被使用，然后验证当前 MessageQueue 是不是已经被 quit 了（mQuitting），验证通过过后就是正式的插入操作。 配置。设置 Message 该有的属性，msg.markInUse(); msg.when = when; 这个方法比较巧妙，将几种具体情况用一份代码解决了，但是都可以归结为：在头结点之前插入结点。看到这里应该注意到，如果插入的是需要非延时 Message，并且线程阻塞了，就会调用 nativeWake(mPtr) 唤醒线程。 当还没有链表的时候（p == 0） 消息的执行时间 比 里面的消息还要早（when == 0 || when &lt; p.when） 在链表中间或最后插入。循环遍历链表，拿到链表合适的 Message，然后再将新 Message 插入。由于还没有到消息的处理时间，就不会唤醒线程。此插入过程如下： 使用 Handler 来 post()先上一个使用的例子：123456789101112131415161718192021private Handler mHandler;//全局变量@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; mHandler = new Handler(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000);//在子线程有一段耗时操作,比如请求网络 mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTestTV.setText(&quot;This is post&quot;);//更新UI &#125; &#125;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();&#125; 例子很简单，就不讲解了，接下来就来看一下 Handler 怎么 post 的吧： 123456789101112131415161718192021/** * Causes the Runnable r to be added to the message queue. * The runnable will be run on the thread to which this handler is * attached. * * @param r The Runnable that will be executed. * * @return Returns true if the Runnable was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. */public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); // 得到一个新的 Message m.callback = r; // 是使用 post 的 Runnable 才会保存有这个参数 return m;&#125; 眼尖的童鞋估计看到就要easy了。在 post 一开始就调用了 sendMessageDelayed(Message msg, long delayMillis)，是不是很眼熟，对的，前面sendMessage(Message msg)一开始也是调用这个方法。这就是非延时消息的插入。后面具体如何插入请参看上一条。 同样的，如果是使用 postDelayed(Runnable r, long delayMillis) 呢？使用例子请参看 面试题：Handler机制，Handler除了线程通信还有什么作用 中的作用二的第二种实现方式。转回来看 Handler 的 postDelayed :1234public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125; 原来啊，大家都用的一套，还是调用的 sendMessageDelayed 方法，只不过延迟时延不再为默认的 0. 这时候就是延迟消息的插入。 退出消息循环退出消息循环有两种方式，分别是Looper 的 quit() 和 quitSafely()1234567public void quit() &#123; mQueue.quit(false); &#125; public void quitSafely() &#123; mQueue.quit(true); &#125; 这还是很简单，直接调用了 MassageQueue 的 qiut(boolean safe) :123456789101112131415161718192021void quit(boolean safe) &#123; if (!mQuitAllowed) &#123; // 主线程设置不允许退出，其他子线程默认设置的true throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; // 默认为 false，表示是否正在退出消息队列 return; &#125; mQuitting = true; // 全局唯一一次赋值，表示正在退出消息队列 if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125;&#125; 首先判断是否是主线程，因为主线程的消息队列不允许退出，然后判断当前线程是否正在退出。值得注意的是，mQuitting 是 MassageQueue 的成员变量，是拥有默认值的，默认值是 false。如果不是正在退出消息队列，则将其标志为 正在退出，注意，全局就只有这里修改了 mQuitting 的值。然后判断根据要求是否安全移除 MessageQueue。 123456789101112131415161718192021222324252627282930313233343536373839404142private void removeAllMessagesLocked() &#123; Message p = mMessages; // 头结点 while (p != null) &#123; Message n = p.next; // 下一个结点 p.recycleUnchecked(); // 前面讲过，就是将数据抹去，放入回收的那个链表 p = n; &#125; mMessages = null; // 将MessageQueue 中保存的头结点设置为 null&#125;private void removeAllFutureMessagesLocked() &#123; final long now = SystemClock.uptimeMillis(); // 从开机到现在的毫秒数（手机睡眠的时间不包括在内）； Message p = mMessages; // 头结点 if (p != null) &#123; // 如果头结点设置的延迟时间 &gt; 大于当前时间 // 注意 这里比较的时候都是用的从开机到现在的毫秒数 // 这里意味着还没有到设置的执行时间 if (p.when &gt; now) &#123; removeAllMessagesLocked(); // 直接移除全部还未到执行时间的 Message &#125; else &#123; Message n; for (;;) &#123; n = p.next; // 拿到下一个节点 if (n == null) &#123; // 结束标志：没有下一个 return; &#125; if (n.when &gt; now) &#123; // 还没有到设置的执行时间，退出循环 break; &#125; p = n; &#125; // 这时候得到的节点 p 是没有到设置的执行时间的前一个节点 // n 是没有到设置的执行时间的节点 p.next = null; do &#123; p = n; n = p.next; p.recycleUnchecked(); &#125; while (n != null); &#125; &#125;&#125; removeAllMessagesLocked()直接将MessageQueue 中的 Message 全部回收掉。无论是延迟消息（延迟消息是指通过sendMessageDelayed或通过postDelayed等方法发送的需要延迟执行的消息）还是非延迟消息（delayMillis == 0）。 removeAllFutureMessagesLocked() 方法呢，就是只会清空MessageQueue消息池中所有的延迟消息，并将消息池中所有的非延迟消息派发出去让Handler去处理，在这个方法中，表现为直接return ，然后因为队列有Message，所以相应的 dispatchMessage(msg) 会调用。 quitSafely相比于quit方法安全之处在于清空消息之前会派发所有的非延迟消息。 面试题handler发消息给子线程，looper怎么启动？ 发消息就是把消息塞进去消息队列，looper在应用起来的时候已经就启动了，一直在轮询取消息队列的消息。 为什么在子线程中创建Handler会抛异常？首先看如下代码:12345678new Thread()&#123; Handler handler = null; @Override public void run() &#123; handler = new Handler(); &#125;&#125;.start(); 前面说过，Looper 对象是 ThreadLocal 的，即每个线程都有自己的 Looper，这个 Looper 可以为空。但是，当你在子线程中创建 Handler 对象时，如果 Looper 为空，那就会抛出异常。源码解释一下： 123456789101112131415public class Handler &#123; ... public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; ...&#125; 从上述程序中，我们可以看到，当 mLooper 对象为空的时候，抛出了异常。这是因为该线程中的 Looper 对象还没有创建，因此 sThreadLocal.get() 会返回 null。Handler 的原理就是要与 MassageQueue 建立关联，并且将消息投递给MassageQueue，如果连 MassageQueue 都没有，那么 Handler 就没有存在的必要，而 MassageQueue 又被封装在 Looper 中，因此，创建 Handler 时 Looper 一定不能为空。解决方法：123456789new Thread()&#123; Handler handler = null; @Override public void run() &#123; Looper.prepare(); // 1. 为当前线程创建 Looper，并会绑定到 ThreadLocal 中 handler = new Handler(); Looper.loop(); // 2. 启动消息循环 &#125; &#125;.start(); 在UI线程为什么可以直接使用呢，就是因为在 ActivityThread中默认帮你执行了 1，2步了的。 Handler为什么loop是死循环。在android中如果主线程（UI线程）中进行耗时操作会引发ANR（Application Not Responding）异常，产生ANR的原因一般有两种： 当前的事件没有机会得到处理（即主线程正在处理前一个事件，没有及时的完成或者looper被某种原因阻塞住了） 当前的事件正在处理，但没有及时完成 比如onCreate()中进行了耗时操作，导致点击、触摸等不响应，就会产生ANR。为了避免ANR异常，android使用了Handler消息处理机制，让耗时操作在子线程运行，需要UI线程进行处理的操作给UI线程发送消息。 我们知道Handler发消息给UI线程就可以处理消息，UI线程维护着一个Looper和一个消息队列，Looper不停的拿消息队列的消息去分发处理。到这里问题来了：如果这么做的话，UI线程岂不是要一直死循环轮询消息队列拿消息？死循环不是造成ANR吗？ 是的，确实是死循环，但是 ANR 还得另说。 ActivityThread 的 main() 1234567public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); ... Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; Looper.loop()1234567891011121314151617181920public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block ... msg.target.dispatchMessage(msg); ... msg.recycleUnchecked(); &#125;&#125; Looper.loop()是在死循环处理消息，如果main方法中没有looper进行循环，那么主线程一运行完毕就会退出，那才不正常了呢！？ 所以，ActivityThread的main方法主要就是做消息循环，一旦退出消息循环，那么你的应用也就退出了。 那么问题重新问一遍：那为什么这个死循环不会造成ANR异常呢？ 其实原因是显然的，我们知道Android是由事件驱动的，Looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞消息。换言之，消息队列为空的时候会阻塞主线程，而处理消息的时候不可以阻塞，这时候的阻塞 5 s就会 ANR。 也就说我们的代码其实就是在这个循环里面去执行的，当然不会阻塞了。 而且主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。 总结：Looer.loop()方法可能会引起主线程的阻塞，但只要它的消息循环没有被阻塞，能一直处理事件就不会产生ANR异常。 Handler 机制 很多细节需要关注：如线程如何建立和退出消息循环等等）这里就是让你回答 Handler 的工作原理。 关于Handler，在任何地方new Handler 都是什么线程下?这个需要分类讨论： 像最开始那样呢，直接new 出来，不带Looper 参数，那么就在创建 Looper 的线程下。 12345678910111213141516171819public Handler() &#123; this(null, false);&#125;public Handler(Callback callback) &#123; this(callback, false);&#125;public Handler(boolean async) &#123; this(null, async);&#125;public Handler(Callback callback, boolean async) &#123; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 在任何地方 new 出指定线程的 Handler。例如主线程，看案例： 1234567new Thread(new Runnable() &#123; @Override public void run() &#123; // 在子线程中实例化Handler同样是可以的，只要在构造函数的参数中传入主线程的Looper即可 Handler handler = new Handler(Looper.getMainLooper()); &#125;&#125;).start(); 前面讲过，UI线程调用的 prepare 函数不一样，多保存了UI线程的 Looper 到 Looper.sMainLooper 中的。其目的是在任何地方都可以实例化 UI 线程的 Handler。 而这时候调用的构造方法是12345678910111213public Handler(Looper looper) &#123; this(looper, null, false);&#125;public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false);&#125;public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 其实就是与传入的 Looper绑定，换言之，如果我传入的是其他线程的Looper，我同样也可以实例化其他线程的 Handler。 请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系讲到Handler，肯定离不开Looper、MessageQueue、Message这三者和Handler之间的关系，下面简略地带过，详细自己可以参看上面源码 Handler将要执行的Message或者Runnable到消息队列。 Looper每一个线程只有一个Looper，每个线程在初始化Looper之后，然后Looper会维护好该线程的消息队列，用来存放Handler发送的Message，并处理消息队列出队的Message。它的特点是它跟它的线程是绑定的，处理消息也是在Looper所在的线程去处理，所以当我们在主线程创建Handler时，它就会跟主线程唯一的Looper绑定，从而我们使用Handler在子线程发消息时，最终也是在主线程处理，达到了异步的效果。 那么就会有人问，为什么我们使用Handler的时候从来都不需要创建Looper呢？这是因为在主线程中，ActivityThread默认会把Looper初始化好，prepare以后，当前线程就会变成一个Looper线程。 MessageQueueMessageQueue是一个消息队列，用来存放Handler发送的消息。每个线程最多只有一个MessageQueue。MessageQueue通常都是由Looper来管理，而主线程创建时，会创建一个默认的Looper对象，而Looper对象的创建，将自动创建一个MessageQueue。其他非主线程，不会自动创建Looper。 Message消息对象，就是MessageQueue里面存放的对象，一个MessageQueu可以包括多个Message。当我们需要发送一个Message时，我们一般不建议使用new Message()的形式来创建，更推荐使用Message.obtain()来获取Message实例，因为在Message类里面定义了一个消息池，当消息池里存在未使用的消息时，便返回，如果没有未使用的消息，则通过new的方式创建返回，所以使用Message.obtain()的方式来获取实例可以大大减少当有大量Message对象而产生的垃圾回收问题。 Handler机制，Handler除了线程通信还有什么作用 Handler的主要用途 : 推送未来某个时间点将要执行的Message或者Runnable到消息队列。 在子线程把需要在另一个线程执行的操作加入到消息队列中去。 1. 推送未来某个时间点将要执行的Message或者Runnable到消息队列实例：通过Handler配合Message或者Runnable实现倒计时 方法一，通过Handler + Message的方式实现倒计时。代码如下：123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; private ActivityMainBinding mBinding; private Handler mHandler ; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); //设置监听事件 mBinding.clickBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //通过Handler + Message的方式实现倒计时 for (int i = 1; i &lt;= 10; i++) &#123; Message message = Message.obtain(mHandler); message.what = 10 - i; mHandler.sendMessageDelayed(message, 1000 * i); //通过延迟发送消息，每隔一秒发送一条消息 &#125; &#125; &#125;); mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); mBinding.time.setText(msg.what + &quot;&quot;); //在handleMessage中处理消息队列中的消息 &#125; &#125;; &#125;&#125; 这里用到了DataBiding，可能没用过的同学看起来有点奇怪，但其实反而简略了代码，有一定基础的同学看起来都不会有太大压力。通过这个小程序，笔者希望大家可以了解到Handler的一个作用就是，在主线程中，可以通过Handler来处理一些有顺序的操作，让它们在固定的时间点被执行。 方法二，通过Handler + Runnable的方式实现倒计时。代码如下：123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; private ActivityMainBinding mBinding; private Handler mHandler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); //设置监听事件 mBinding.clickBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; for (int i = 1; i &lt;= 10; i++) &#123; final int fadedSecond = i; //每延迟一秒，发送一个Runnable对象 mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mBinding.time.setText((10 - fadedSecond) + &quot;&quot;); &#125; &#125;, 1000 * i); &#125; &#125; &#125;); &#125;&#125; 方法二也是通过代码让大家加深Handler处理有序事件的用途，之所以分开Runnable和Message两种方法来实现，是因为很多人都搞不清楚为什么Handler可以推送Runnable和Message两种对象。 其实，无论Handler将Runnable还是Message加入MessageQueue，最终都只是将Message加入到MessageQueue。Handler的post Runnable对象这个方法只是对post Message进行了一层封装，即将Runnable 放到的Message 中的 mCallback 存储起来，值得注意的是，如果直接将Message 加入MessageQueue的话，那么mCallback将为null，所以最终我们都是通过Handler推送了一个Message罢了，至于为什么会分开两种方法，只是为了更方便开发者根据不同需要进行调用。下面再来看看Handler的第二个主要用途。 2. 在子线程把需要在另一个线程执行的操作加入到消息队列中去实例：通过Handler + Message来实现子线程加载图片，在UI线程显示图片 效果图如下代码如下(布局代码也不放出来了)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class ThreadActivity extends AppCompatActivity implements View.OnClickListener &#123; private ActivityThreadBinding mBinding = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mBinding = DataBindingUtil.setContentView(this, R.layout.activity_thread); // 设置点击事件 mBinding.clickBtn.setOnClickListener(this); mBinding.resetBtn.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; // 响应load按钮 case R.id.clickBtn: // 开启一个线程 new Thread(new Runnable() &#123; @Override public void run() &#123; // 在Runnable中进行网络读取操作，返回bitmap final Bitmap bitmap = loadPicFromInternet(); // 在子线程中实例化Handler同样是可以的，只要在构造函数的参数中传入主线程的Looper即可 Handler handler = new Handler(Looper.getMainLooper()); // 通过Handler的post Runnable到UI线程的MessageQueue中去即可 handler.post(new Runnable() &#123; @Override public void run() &#123; // 在MessageQueue出队该Runnable时进行的操作 mBinding.photo.setImageBitmap(bitmap); &#125; &#125;); &#125; &#125;).start(); break; case R.id.resetBtn: mBinding.photo.setImageBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.default_pic)); break; &#125; &#125; /*** * HttpUrlConnection加载图片，很简单 * @return */ public Bitmap loadPicFromInternet() &#123; Bitmap bitmap = null; int respondCode = 0; InputStream is = null; try &#123; URL url = new URL(&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1421494343,3838991329&amp;fm=23&amp;gp=0.jpg&quot;); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.setConnectTimeout(10 * 1000); connection.setReadTimeout(5 * 1000); connection.connect(); respondCode = connection.getResponseCode(); if (respondCode == 200) &#123; is = connection.getInputStream(); bitmap = BitmapFactory.decodeStream(is); &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); Toast.makeText(getApplicationContext(), &quot;访问失败&quot;, Toast.LENGTH_SHORT).show(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return bitmap; &#125;&#125; 很简单，其实最主要的就是当我们需要在主线程执行一些操作的时候，就可以直接使用这种方式，这种方式有着直接发送 Message 不可实现的先天优势。 handler机制组成，handler机制每一部分的源码包括looper中的loop方法、threadlocal概念、dispatchmessage方法源码，runnable封装message等上面讲解的还记得住么？ 请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系 Android的单线程模型 当一个程序第一次启动时，Android会同时启动一个对应的主线程（Main Thread），主线程主要负责处理与UI相关的事件，如：用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理。所以主线程通常又被叫做UI线程。 在开发Android 应用时必须遵守单线程模型的原则：Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。 如果在非UI线程中直接操作UI线程，会抛出异常，这与普通的java程序不同。因为 ViewRootImpl 对 UI 操作做了验证，这个验证工作是由 ViewRootImpl 的 checkThread 方法来完成的：123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); &#125;&#125; 由于UI线程负责事件的监听和绘图，因此，必须保证UI线程能够随时响应用户的需求，UI线程里的操作应该向中断事件那样短小，费时的操作（如网络连接）需要另开线程，否则，如果UI线程超过5s没有响应用户请求，会弹出对话框提醒用户终止应用程序。顺便说一下 ANR 默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。 如果在新开的线程那为什么系统不对 UI 控件的访问加上锁机制呢？缺点有两个：首先加上锁机制会让 UI 访问的逻辑变得复杂；其次锁机制会降低 UI 访问的效率，因为锁机制会阻塞某些线程的执行。鉴于这两个缺点，最简单且高效的方法就是采用单线程模型来处理UI操作，对于开发者来说也不是很麻烦，只需要通过 Handler 切换一下 UI 访问的执行线程就好。中需要对UI进行设定，就可能违反单线程模型，因此android采用一种复杂的Message Queue机制保证线程间通信。 后面就是分析的那一套了。Message Queue 、 Handler 、 Looper Handler、Thread和HandlerThread的差别123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; /** * Constructs a HandlerThread. * @param name * @param priority The priority to run the thread at. The value supplied must be from * &#123;@link android.os.Process&#125; and not from java.lang.Thread. */ public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; /** * Call back method that can be explicitly overridden if needed to execute some * setup before Looper loops. */ protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; /** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason is isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */ public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; /** * Quits the handler thread&apos;s looper. * &lt;p&gt; * Causes the handler thread&apos;s looper to terminate without processing any * more messages in the message queue. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt;&lt;p class=&quot;note&quot;&gt; * Using this method may be unsafe because some messages may not be delivered * before the looper terminates. Consider using &#123;@link #quitSafely&#125; instead to ensure * that all pending work is completed in an orderly manner. * &lt;/p&gt; * * @return True if the looper looper has been asked to quit or false if the * thread had not yet started running. * * @see #quitSafely */ public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; /** * Quits the handler thread&apos;s looper safely. * &lt;p&gt; * Causes the handler thread&apos;s looper to terminate as soon as all remaining messages * in the message queue that are already due to be delivered have been handled. * Pending delayed messages with due times in the future will not be delivered. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt;&lt;p&gt; * If the thread has not been started or has finished (that is if * &#123;@link #getLooper&#125; returns null), then false is returned. * Otherwise the looper is asked to quit and true is returned. * &lt;/p&gt; * * @return True if the looper looper has been asked to quit or false if the * thread had not yet started running. */ public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125; public int getThreadId() &#123; return mTid; &#125;&#125; 由于 HandlerThread 实在是代码少得变态，我就直接将全部源码贴上来了。 直接看一下run() 方法可能就明白了，就是将 Looper 启动起来，就等于主线程一样，可以直接使用 Handler 了，没必要 Looper.prepare() 再 Looper.loop() 了。需要知道这根本不是 handler ，而是封装了 Looper 的 Thread，方便了子线程与子线程通信。 还有一点Handler: 它的消息处理方式是阻塞式的，必须一条一条的处理。耗时操作 不应该用handler处理。 HandlerThread：继承自Thread，它有个Looper，在这里可以执行耗时操作 什么是 IdleHandler？有什么用？怎么用https://mp.weixin.qq.com/s/KpeBqIEYeOzt_frANoGuSg这里还没写，努力更新中… Handler消息机制，postDelayed会造成线程阻塞吗？对内存有什么影响？ Handler消息机制 postDelayed会造成线程阻塞吗： 还有印象么，上面讲解的 postDelayed。postDelayed只是在 post 的时候加了延时，最后这个延时讲被转换成执行时间存在每一个 Message 中。而在 loop() 中调用 next() 的死循环是阻塞式的，只有在下个消息到达或者有事务发生（设置的nextPollTimeoutMillis到了）时，才通过往pipe管道写端写入数据来唤醒线程工作。 也就是说如果当前消息队列中消息全部为 延时Message（全部没到执行时间），而这个 Message 的执行时间又比MessageQueue 中所有消息执行时间早，那么在loop循环取next 的时候就会因为最早这一个Message（刚刚postDelayed的Message）还没到执行时间而阻塞。 对内存有什么影响Looper 是通过 ThreadLocal 存储在线程中的，而MessageQueue 是封装在 Looper 中的。 参考文章：Android 官方文档 ：Handler MessageQueueLooper)《 Android 开发艺术探索 》《 Android 开发进阶 从小工到专家 》深入理解Android中的Handler机制一步一步分析Android的Handler机制【从源码看Android】03Android MessageQueue消息循环处理机制（epoll实现）]]></content>
      <categories>
        <category>Android系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal 原理]]></title>
    <url>%2F2018%2F07%2F24%2FThreadLocal%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[总述ThreadLocal 在面试中经常提到，关于ThreadLocal使用不当造成OOM以及在特殊场景下，通过ThreadLocal可以轻松实现一些看起来复杂的功能，都说明值得花时间研究其原理。 ThreadLocal 不是 Thread，是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，对数据存储后，只有在线程中才可以获取到存储的数据，对于其他线程来说是无法获取到数据。可能这才是Local的真正含义吧。 使用场景对于 ThreadLocal 的使用场景，一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。比如对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的存取，如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定线程的Looper，这样一来就必须提供一个类似于LooperManager的类了，但是系统并没有这么做而是选择了ThreadLocal，这就是ThreadLocal的好处。 ThreadLocal另一个使用场景是复杂逻辑下的对象传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？其实就可以采用ThreadLocal，采用ThreadLocal可以让监听器作为线程内的全局对象而存在，在线程内部只要通过get方法就可以获取到监听器。而如果不采用ThreadLocal，那么我们能想到的可能是如下两种方法：第一种方法是将监听器通过参数的形式在函数调用栈中进行传递，第二种方法就是将监听器作为静态变量供线程访问。上述这两种方法都是有局限性的。第一种方法的问题时当函数调用栈很深的时候，通过函数参数来传递监听器对象这几乎是不可接受的，这会让程序的设计看起来很糟糕。第二种方法是可以接受的，但是这种状态是不具有可扩充性的，比如如果同时有两个线程在执行，那么就需要提供两个静态的监听器对象，如果有10个线程在并发执行呢？提供10个静态的监听器对象？这显然是不可思议的，而采用ThreadLocal每个监听器对象都在自己的线程内部存储，根据就不会有方法2的这种问题。 使用 Demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ThreadLocalTest &#123; public static void main(String[] args) &#123; final ThreadLocal&lt;String&gt; threadLocal1 = new ThreadLocal&lt;&gt;(); final ThreadLocal&lt;Integer&gt; threadLocal2 = new ThreadLocal&lt;&gt;(); new Thread(new Runnable() &#123; @Override public void run() &#123; threadLocal1.set("A"); threadLocal2.set(1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); System.out.println(threadLocal1.get()); System.out.println(threadLocal2.get()); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; threadLocal1.set("B"); threadLocal2.set(2); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); System.out.println(threadLocal1.get()); System.out.println(threadLocal2.get()); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); System.out.println(threadLocal1.get()); System.out.println(threadLocal2.get()); &#125; &#125;).start(); &#125;&#125; 结果如下：123456789Thread-2nullnullThread-1B2Thread-0A1 为了简单理解，这时候只看threadLocal1 就好，从上面日志可以看出，虽然在不同线程中访问的是同一个ThreadLocal对象，但是它们通过ThreadLocal来获取到的值却是不一样的，这就是ThreadLocal的奇妙之处。 ThreadLocal之所以有这么奇妙的效果，是因为不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值，很显然，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不干扰。 可能这样说还是很懵，后面讲原理后会给出他的UML图。 ThreadLocal 的内部实现JDK和SDK的ThreadLocal其实在构想上是一样的，只不过具体代码实现是有些不同。这里讲解的是 Android API 25 的源码。 说了这么多，都是虚的，看源码啦 1public class ThreadLocal&lt;T&gt; 抬头一看，泛型类，仔细的朋友估计在前面的使用的时候估计就已经猜到了。而传进来的泛型T的类型就是ThreadLocal需要保存的数据类型。 ThreadLocal.ThreadLocalMap 内部类参数在弄清存取过程之前先解决放在哪里的问题。 ThreadLocalMap 就是用来存储的内部类，现在就先介绍存储的ThreadLocalMap的部分参数和构造方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 static class ThreadLocalMap &#123; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125; &#125; /** * The initial capacity -- MUST be a power of two. */ private static final int INITIAL_CAPACITY = 16; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table; /** * The number of entries in the table. */ private int size = 0; /** * The next size value at which to resize. */ private int threshold; // Default to 0 // ... ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; /** * Set the resize threshold to maintain at worst a 2/3 load factor. */ private void setThreshold(int len) &#123; threshold = len * 2 / 3; &#125;&#125; 由上述代码可知，Entry 是一个包含 key 和 value 的一个对象，Entry的key为ThreadLocal，value为ThreadLocal对应的值，只不过是对这个Entry做了一些特殊处理，即 使用 WeakReference&lt;ThreadLocal&gt;将 ThreadLocal对象变成一个弱引用的对象，这样做的好处就是在线程销毁的时候，对应的实体就会被回收，不会出现内存泄漏。 其余的都很简单，需要说的是 Entry[] table 就是最后存放数据的地方，而默认的大小呢，就是 16，当大于等于容量的 2/3 的时候重新分配table，具体什么时候分配下面再介绍。 set 方法既然 ThreadLocal是线程内部的数据存储类，只要弄清楚ThreadLocal的get和set方法就可以明白它的工作原理。 接下来就是重点了，当然是 set()，源代码如下：12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 在上述源码中，首先会通过 getMap() 方法来获取当前线程中的 ThreadLocal 数据。获取的方法就是：直接去当前Thread t 中访问。因为在 Thread 类中有一个成员变量 ThreadLocal.ThreadLocalMap threadLocals = null;专门用于存储线程的 ThreadLocal 数据，他们的关系的UML图请看下面。这时候如果 threadLocals 为 null 的时候，就调用 createMap(t, value); 进行初始化，并把数据放进去，这个构造方法就在上面。 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 接下来就分析一下上面中的 map.set(this, value) 的 set 方法，需要说明一下的是这个方法是在内部类ThreadLocalMap里面。 12345678910111213141516171819202122232425262728293031323334private void set(ThreadLocal key, Object value) &#123; // We don&apos;t use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; // 通过传入的key的hashCode计算出索引的位置 // 且运算，得到下标，这样子不容易重复 int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 我们来讲接一下 set里面的算法，首先是拿到当前 table 的长度，计算出下标，然后从计算出的下标开始循环： 如果当前指向的 Entry 是存储过的 ThreadLocal，就直接将以前的数据覆盖掉，并结束。 如果当前这个的 Entry 是一个陈旧Entry（有对象但是k == null），那就调用 replaceStaleEntry(key, value, i);将数据存储进去，并结束。 如果循环的找到一个空的数组，将退出循环，然后将值存在这里，size+1。值得注意的是最后一段代码，这里执行了一次cleanSomeSlots(int i, int n)，这个方法呢，也很简单，就是清除部分的陈旧Entry，如果清除不成功，并且大于等于负载阈值 threshold （当前size的2/3）的时候就会 rehash。至此数据就成功存储进去了。 set() 方法讲完了，简单理一下Thread，ThreadLocal，ThreadLocalMap之间的关系: 这时候是不是返回去看那个例子就能看懂了呢 每一个 Thread 中都保存着自己的一个 ThreadLocalMap，这就是为什么每个 ThreadLocal 保存进去的东西独立而多样，ThreadLocal 就像是定义了一次操作，当前 ThreadLocal 能够对指定的线程进行存取一份数据。 面试题：ThreadLocal 如何保证Local属性？ 当需要使用多线程时，有个变量恰巧不需要共享，此时就不必使用synchronized这么麻烦的关键字来锁住，每个线程都相当于在堆内存中开辟一个空间，线程中带有对共享变量的缓冲区，通过缓冲区将堆内存中的共享变量进行读取和操作，ThreadLocal相当于线程内的内存，一个局部变量。每次可以对线程自身的数据读取和操作，并不需要通过缓冲区与 主内存中的变量进行交互。并不会像synchronized那样修改主内存的数据，再将主内存的数据复制到线程内的工作内存。ThreadLocal可以让线程独占资源，存储于线程内部，避免线程堵塞造成CPU吞吐下降。 在每个Thread中包含一个ThreadLocalMap，ThreadLocalMap的key是ThreadLocal的对象，value是独享数据。 rehash() 扩容这一部分呢，比较简单，就简单讲解一下。1234567 private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize();&#125; 首先一来就调用了 expungeStaleEntries() 来去除陈旧无用的Entry（key == null），那怎么去除就请接着看。123456789private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) expungeStaleEntry(j); &#125;&#125; 这也是特别简单的，就去遍历一遍 table 数组，挨个判断每一个是不是陈旧(key==null)的Entry，但是具体怎么去除单个无用的Entry呢？12345678910111213141516171819202122232425262728293031323334353637private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot // 将tab上staleSlot位置的对象清空 tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); // 遍历下一个元素, 即(i+1)%len位置的元素 (e = tab[i]) != null; // 遍历到Entry为空时, 跳出循环并返回索引位置 i = nextIndex(i, len)) &#123; ThreadLocal k = e.get(); if (k == null) &#123; // 当前遍历Entry的key为空, 则将该位置的对象清空 e.value = null; tab[i] = null; size--; &#125; else &#123; // 当前遍历Entry的key不为空 int h = k.threadLocalHashCode &amp; (len - 1); // 重新计算该Entry的索引位置 if (h != i) &#123; // 如果索引位置不为当前索引位置i tab[i] = null; // 则将i位置对象清空, 替当前Entry寻找正确的位置(当前对象已经保存在e中了) // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. // 如果h位置不为null，则向h后寻找当前Entry的位置 while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i; &#125; 回收的算法也很简单，staleSlot开始，清除key为null的Entry，并将不为空的元素放到合适的位置，最后遍历到Entry为空的元素时，跳出循环返回当前索引位置。 这里说一下，这里的 tab[h] != null，这种情况就是哈希碰撞，这种处理hash碰撞的方法就是开放地址法中的线性探测再散列，这里不细讲，列两个公式，相信你会懂： Hi = （H（key）+ di）MOD m i = 1,2,3,4…,k (k&lt;=m-1) H（key）为哈希函数；m为哈希表表长；di为增量序列 线性探测再散列 di = 1,2,3,4,…,m-1 二次探测再散列 di = 1^2, -1^2, 2^2, -2^2, 3^2, -3^2, … +-k^2 (k&lt;=m/2) 伪随机探测再散列 di = 伪随机序列数这里的哈希函数是：key.threadLocalHashCode &amp; (table.length - 1) 至此，去除陈旧无用的 expungeStaleEntries() 就执行完了，接下来就是一个判断，因为当前又清除了一遍，table里面使用了的size已经变化，当 size &gt;= threshold - threshold / 4 即 数组table长度 len 2 / 3 - len 2 / 3 / 4 = 1/2 * len，意味着当清除后如果还是超过一半的话，就进行扩容。那如何扩容呢？resize()啊。12345678910111213141516171819202122232425262728private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); // 检测碰撞， while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab;&#125; 这一部分也是很简单，最重要的就是 int newLen = oldLen * 2; 说明扩容是以两倍进行扩容。resize() 其实就是先申请两倍长度的table数组，然后将数据拷贝到合适位置，然后将新的table数组的引用赋值给原来的table。 get 方法12345678910public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; 在外面调用 get 就会当前线程存储的数据，首先拿到当前Thread中的保存的 ThreadLocal.ThreadLocalMap threadLocals，判空，本着先易后难的原则，先看 setInitialValue():12345678910private T setInitialValue() &#123; T value = initialValue(); // return null Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 这里的 value 是恒为null的，在get调用的时候呢，map一定null，就会初始化一个 ThreadLocalMap 给当前Thread，并将为null的value存进去（啥都没存好么）。那这里返回值就为null，意味着当当前Thread没有ThreadLocal时，返回null，符合直觉。 那退一步说，如果当前Thread村过值了呢，那 ThreadLocalMap map 就不会为空，接着调用 ThreadLocalMap 中的 getEntry() 得到想要的Entry。12345678private Entry getEntry(ThreadLocal key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125; 同过哈希函数算出下标，然后比较当前的key(ThreadLocal)是不是要找的那个Thread 的 ThreadLocal，如果不是则调用 getEntryAfterMiss(key, i, e) 从当前节点开始线性查找。 12345678910111213141516private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null; &#125; 没什么好说的，从给定位置进行线性探测（循环），如果是就返回，只不过他在比较好的是判断了当前Entry 是否是陈旧无用的，如果是，就调用expungeStaleEntry(i) 去掉（前面有讲到这个方法）。 需要解释一下两个问题 为什么循环的终止条件为什么是一旦找到一个空对象就停止返回null（表示没找到）呢？ 答： 在进行放的时候，如果哈希碰撞了，就会进行线性探测再散列，现在挨着挨着找，如果当时是存放了数据的话，那么就会放到第一个是空的地方，然后第一个为空的地方不为空了，而现在取的时候都出现null的现象了，说明根本没有存过。 expungeStaleEntry(i) 中的重新放置不会放到当前i之前么？从而导致存了，却取不到数据现象。 答：不会，首先能保证的是从哈希函数算出的下标 H(key) 开始到当前的Entry 都是有效的，因为i开始就判断了 k == key 的，其次 expungeStaleEntry(staleSlot) 是从staleSlot开始，清除key为null的Entry，试想如果当前处理位置的下一位就是 目标Thread 的 ThreadLocalMap ，那么它将会被放在当前位置，因为，当前位置一定为空，从H(key)到当前位置一定都有其他Entry占着位置，这时候在 getEntryAfterMiss(ThreadLocal key, int i, Entry e) 中会再一次取当前位置的值，然后判断。 总结： 每一个线程都有变量 ThreadLocal.ThreadLocalMap threadLocals保存着自己的 ThreadLocalMap。 ThreadLocal 所操作的是当前线程的 ThreadLocalMap 对象中的 table 数组，并把操作的 ThreadLocal 作为键存储。 自定义ThreadLocal问题：多线程下，如何实现一个ThreadLoacl笔者提供的简单例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class SimpleThreadLocal&lt;T&gt;&#123; /** * Key为线程对象，Value为传入的值对象 */ private Map&lt;Thread, T&gt; valueMap = Collections.synchronizedMap(new HashMap&lt;Thread, T&gt;()); /** * 设值 * @param value Map键值对的value */ public void set(T value) &#123; valueMap.put(Thread.currentThread(), value); &#125; /** * 取值 * @return */ public T get() &#123; Thread currentThread = Thread.currentThread(); //返回当前线程对应的变量 T t = valueMap.get(currentThread); //如果当前线程在Map中不存在，则将当前线程存储到Map中 if (t == null &amp;&amp; !valueMap.containsKey(currentThread)) &#123; t = initialValue(); valueMap.put(currentThread, t); &#125; return t; &#125; public void remove() &#123; valueMap.remove(Thread.currentThread()); &#125; public T initialValue() &#123; return null; &#125; public static void main(String[] args) &#123; SimpleThreadLocal&lt;List&lt;String&gt;&gt; threadLocal = new SimpleThreadLocal&lt;&gt;(); new Thread(() -&gt; &#123; List&lt;String&gt; params = new ArrayList&lt;&gt;(3); params.add(&quot;张三&quot;); params.add(&quot;李四&quot;); params.add(&quot;王五&quot;); threadLocal.set(params); System.out.println(Thread.currentThread().getName()); threadLocal.get().forEach(param -&gt; System.out.println(param)); &#125;).start(); new Thread(() -&gt; &#123; try &#123; Thread.sleep(1000); List&lt;String&gt; params = new ArrayList&lt;&gt;(2); params.add(&quot;Chinese&quot;); params.add(&quot;English&quot;); threadLocal.set(params); System.out.println(Thread.currentThread().getName()); threadLocal.get().forEach(param -&gt; System.out.println(param)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; 运行结果：1234567Thread-0张三李四王五Thread-1ChineseEnglish 自此，ThreadLocal的分析就结束了。 参考资料：Android 开发艺术探索thinking in javaAndroid与Java中的ThreadLocal对ThreadLocal实现原理的一点思考Java并发：ThreadLocal详解Java多线程编程-（8）-多图深入分析ThreadLocal原理轻松使用线程 不共享有时是最好的 利用 ThreadLocal 提高可伸缩性]]></content>
      <categories>
        <category>Android系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
</search>
